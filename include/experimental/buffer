#ifndef NET_BUFFER
#define NET_BUFFER

#include <array>
#include <string>
#include <string_view>
#include <system_error>
#include <type_traits>
#include <vector>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class stream_errc
{
    eof = 2,
    not_found = 3
};

struct _Stream_category : error_category
{
    const char* name() const noexcept override { return "stream"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(stream_errc::eof):
            return "End of file";
        case static_cast<int>(stream_errc::not_found):
            return "Element not found";
        default:
            return "stream error";
        }
    }
};

inline const error_category& stream_category() noexcept
{
    static _Stream_category instance{};
    return instance;
}

inline error_code make_error_code(stream_errc e) noexcept { return error_code(static_cast<int>(e), stream_category()); }
inline error_condition make_error_condition(stream_errc e) noexcept { return error_condition(static_cast<int>(e), stream_category()); }

class mutable_buffer
{
public:
    mutable_buffer() noexcept : data_(nullptr), size_(0) {}
    mutable_buffer(void* p, size_t n) noexcept : data_(p), size_(n) {}

    void* data() const noexcept { return data_; }
    size_t size() const noexcept { return size_; }
    mutable_buffer& operator+=(size_t n) noexcept
    {
        n = n < size_ ? n : size_;
        data_ = static_cast<char*>(data_) + n;
        size_ -= n;
        return *this;
    }

private:
    void* data_;
    size_t size_;

    friend class const_buffer;
};
class const_buffer
{
public:
    const_buffer() noexcept : data_(nullptr), size_(0) {}
    const_buffer(const void* p, size_t n) noexcept : data_(p), size_(n) {}
    const_buffer(const mutable_buffer& b) noexcept : data_(b.data_), size_(b.size_) {}

    const void* data() const noexcept { return data_; }
    size_t size() const noexcept { return size_; }
    const_buffer& operator+=(size_t n) noexcept
    {
        n = n < size_ ? n : size_;
        data_ = static_cast<const char*>(data_) + n;
        size_ -= n;
        return *this;
    }

private:
    const void* data_;
    size_t size_;
};

template <class T, class = void, class = void>
struct is_mutable_buffer_sequence : false_type
{
};
template <class T,
          class = void_t<decltype(buffer_sequence_begin(declval<T>()))>,
          class = void_t<decltype(buffer_sequence_end(declval<T>()))>>
struct is_mutable_buffer_sequence : true_type
{
};

template <class T, class = void, class = void>
struct is_const_buffer_sequence : false_type
{
};
template <class T,
          class = void_t<decltype(buffer_sequence_begin(declval<T>()))>,
          class = void_t<decltype(buffer_sequence_end(declval<T>()))>>
struct is_const_buffer_sequence : true_type
{
};

template <class T, class = void, class = void, class = void, class = void, class = void, class = void, class = void, class = void, class = void>
struct is_dynamic_buffer : false_type
{
};
template <class T,
          class = void_t<typename T::const_buffers_type>,
          class = void_t<typename T::mutable_buffers_type>,
          class = void_t<decltype(declval<T>().size())>,
          class = void_t<decltype(declval<T>().max_size())>,
          class = void_t<decltype(declval<T>().capacity())>,
          class = void_t<decltype(declval<T>().data())>,
          class = void_t<decltype(declval<T>().prepare(0))>,
          class = void_t<decltype(declval<T>().commit(0))>,
          class = void_t<decltype(declval<T>().consume(0))>>
struct is_dynamic_buffer : true_type
{
};

template <class T>
constexpr bool is_mutable_buffer_sequence_v{ is_mutable_buffer_sequence<T>::value };
template <class T>
constexpr bool is_const_buffer_sequence_v{ is_const_buffer_sequence<T>::value };
template <class T>
constexpr bool is_dynamic_buffer_v{ is_dynamic_buffer<T>::value };

inline const mutable_buffer* buffer_sequence_begin(const mutable_buffer& b) noexcept { return addressof(b); }
inline const const_buffer* buffer_sequence_begin(const const_buffer& b) noexcept { return addressof(b); }
inline const mutable_buffer* buffer_sequence_end(const mutable_buffer& b) noexcept { return addressof(b) + 1; }
inline const const_buffer* buffer_sequence_end(const const_buffer& b) noexcept { return addressof(b) + 1; }
template <class C>
inline decltype(auto) buffer_sequence_begin(C& c) noexcept
{
    return c.begin();
}
template <class C>
inline decltype(auto) buffer_sequence_begin(const C& c) noexcept
{
    return c.begin();
}
template <class C>
inline decltype(auto) buffer_sequence_end(C& c) noexcept
{
    return c.end();
}
template <class C>
inline decltype(auto) buffer_sequence_end(const C& c) noexcept
{
    return c.end();
}

template <class ConstBufferSequence>
inline size_t buffer_size(const ConstBufferSequence& buffers) noexcept
{
    size_t total_size{ 0 };
    auto i{ buffer_sequence_begin(buffers) };
    auto end{ buffer_sequence_end(buffers) };
    for (; i != end; ++i)
    {
        const_buffer b{ *i };
        total_size += b.size();
    }
    return total_size;
}
template <class MutableBufferSequence, class ConstBufferSequence>
inline size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source) noexcept;
template <class MutableBufferSequence, class ConstBufferSequence>
inline size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source, size_t max_size) noexcept;

mutable_buffer operator+(const mutable_buffer& b, size_t n) noexcept;
mutable_buffer operator+(size_t n, const mutable_buffer& b) noexcept;
const_buffer operator+(const const_buffer&, size_t n) noexcept;
const_buffer operator+(size_t, const const_buffer&) noexcept;

mutable_buffer buffer(void* p, size_t n) noexcept;
const_buffer buffer(const void* p, size_t n) noexcept;

mutable_buffer buffer(const mutable_buffer& b) noexcept;
mutable_buffer buffer(const mutable_buffer& b, size_t n) noexcept;
const_buffer buffer(const const_buffer& b) noexcept;
const_buffer buffer(const const_buffer& b, size_t n) noexcept;

template <class T, size_t N>
mutable_buffer buffer(T (&data)[N]) noexcept;
template <class T, size_t N>
const_buffer buffer(const T (&data)[N]) noexcept;
template <class T, size_t N>
mutable_buffer buffer(array<T, N>& data) noexcept;
template <class T, size_t N>
const_buffer buffer(array<const T, N>& data) noexcept;
template <class T, size_t N>
const_buffer buffer(const array<T, N>& data) noexcept;
template <class T, class Allocator>
mutable_buffer buffer(vector<T, Allocator>& data) noexcept;
template <class T, class Allocator>
const_buffer buffer(const vector<T, Allocator>& data) noexcept;
template <class CharT, class Traits, class Allocator>
mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data) noexcept;
template <class CharT, class Traits, class Allocator>
const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data) noexcept;
template <class CharT, class Traits>
const_buffer buffer(basic_string_view<CharT, Traits> data) noexcept;

template <class T, size_t N>
mutable_buffer buffer(T (&data)[N], size_t n) noexcept;
template <class T, size_t N>
const_buffer buffer(const T (&data)[N], size_t n) noexcept;
template <class T, size_t N>
mutable_buffer buffer(array<T, N>& data, size_t n) noexcept;
template <class T, size_t N>
const_buffer buffer(array<const T, N>& data, size_t n) noexcept;
template <class T, size_t N>
const_buffer buffer(const array<T, N>& data, size_t n) noexcept;
template <class T, class Allocator>
mutable_buffer buffer(vector<T, Allocator>& data, size_t n) noexcept;
template <class T, class Allocator>
const_buffer buffer(const vector<T, Allocator>& data, size_t n) noexcept;
template <class CharT, class Traits, class Allocator>
mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept;
template <class CharT, class Traits, class Allocator>
const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept;
template <class CharT, class Traits>
const_buffer buffer(basic_string_view<CharT, Traits> data, size_t n) noexcept;

template <class T, class Allocator>
class dynamic_vector_buffer;

template <class CharT, class Traits, class Allocator>
class dynamic_string_buffer;

template <class T, class Allocator>
dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec) noexcept;
template <class T, class Allocator>
dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec, size_t n) noexcept;

template <class CharT, class Traits, class Allocator>
dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str) noexcept;
template <class CharT, class Traits, class Allocator>
dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str, size_t n) noexcept;

class transfer_all;
class transfer_at_least;
class transfer_exactly;

template <class SyncReadStream, class MutableBufferSequence>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers);
template <class SyncReadStream, class MutableBufferSequence>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, error_code& ec);
template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition);
template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec);

template <class SyncReadStream, class DynamicBuffer>
size_t read(SyncReadStream& stream, DynamicBuffer&& b);
template <class SyncReadStream, class DynamicBuffer>
size_t read(SyncReadStream& stream, DynamicBuffer&& b, error_code& ec);
template <class SyncReadStream, class DynamicBuffer, class CompletionCondition>
size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition);
template <class SyncReadStream, class DynamicBuffer, class CompletionCondition>
size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec);

template <class AsyncReadStream, class MutableBufferSequence, class CompletionToken>
auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionToken&& token);
template <class AsyncReadStream, class MutableBufferSequence, class CompletionCondition, class CompletionToken>
auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);

template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionCondition, class CompletionToken>
auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);

template <class SyncWriteStream, class ConstBufferSequence>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers);
template <class SyncWriteStream, class ConstBufferSequence>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, error_code& ec);
template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition);
template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec);

template <class SyncWriteStream, class DynamicBuffer>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b);
template <class SyncWriteStream, class DynamicBuffer>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b, error_code& ec);
template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition);
template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec);

template <class AsyncWriteStream, class ConstBufferSequence, class CompletionToken>
auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionToken&& token);
template <class AsyncWriteStream, class ConstBufferSequence, class CompletionCondition, class CompletionToken>
auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);

template <class AsyncWriteStream, class DynamicBuffer, class CompletionToken>
auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionToken&& token);
template <class AsyncWriteStream, class DynamicBuffer, class CompletionCondition, class CompletionToken>
auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);

template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim);
template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim, error_code& ec);
template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim);
template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim, error_code& ec);

template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, char delim, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, string_view delim, CompletionToken&& token);
} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::stream_errc> : public true_type
{
};
} // namespace std

#endif
