#ifndef NET_BUFFER
#define NET_BUFFER

#include <array>
#include <string>
#include <string_view>
#include <system_error>
#include <type_traits>
#include <vector>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class stream_errc
{
    eof = 2,
    not_found = 3
};

const error_category& stream_category() noexcept;

error_code make_error_code(stream_errc e) noexcept;
error_condition make_error_condition(stream_errc e) noexcept;

class mutable_buffer;
class const_buffer;

template <class T>
struct is_mutable_buffer_sequence;
template <class T>
struct is_const_buffer_sequence;
template <class T>
struct is_dynamic_buffer;

template <class T>
constexpr bool is_mutable_buffer_sequence_v{ is_mutable_buffer_sequence<T>::value };
template <class T>
constexpr bool is_const_buffer_sequence_v{ is_const_buffer_sequence<T>::value };
template <class T>
constexpr bool is_dynamic_buffer_v{ is_dynamic_buffer<T>::value };

const mutable_buffer* buffer_sequence_begin(const mutable_buffer& b) noexcept;
const const_buffer* buffer_sequence_begin(const const_buffer& b) noexcept;
const mutable_buffer* buffer_sequence_end(const mutable_buffer& b) noexcept;
const const_buffer* buffer_sequence_end(const const_buffer& b) noexcept;
template <class C>
auto buffer_sequence_begin(C& c) noexcept -> decltype(c.begin());
template <class C>
auto buffer_sequence_begin(const C& c) noexcept -> decltype(c.begin());
template <class C>
auto buffer_sequence_end(C& c) noexcept -> decltype(c.end());
template <class C>
auto buffer_sequence_end(const C& c) noexcept -> decltype(c.end());

template <class ConstBufferSequence>
size_t buffer_size(const ConstBufferSequence& buffers) noexcept;
template <class MutableBufferSequence, class ConstBufferSequence>
size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source) noexcept;
template <class MutableBufferSequence, class ConstBufferSequence>
size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source, size_t max_size) noexcept;

mutable_buffer operator+(const mutable_buffer& b, size_t n) noexcept;
mutable_buffer operator+(size_t n, const mutable_buffer& b) noexcept;
const_buffer operator+(const const_buffer&, size_t n) noexcept;
const_buffer operator+(size_t, const const_buffer&) noexcept;

mutable_buffer buffer(void* p, size_t n) noexcept;
const_buffer buffer(const void* p, size_t n) noexcept;

mutable_buffer buffer(const mutable_buffer& b) noexcept;
mutable_buffer buffer(const mutable_buffer& b, size_t n) noexcept;
const_buffer buffer(const const_buffer& b) noexcept;
const_buffer buffer(const const_buffer& b, size_t n) noexcept;

template <class T, size_t N>
mutable_buffer buffer(T (&data)[N]) noexcept;
template <class T, size_t N>
const_buffer buffer(const T (&data)[N]) noexcept;
template <class T, size_t N>
mutable_buffer buffer(array<T, N>& data) noexcept;
template <class T, size_t N>
const_buffer buffer(array<const T, N>& data) noexcept;
template <class T, size_t N>
const_buffer buffer(const array<T, N>& data) noexcept;
template <class T, class Allocator>
mutable_buffer buffer(vector<T, Allocator>& data) noexcept;
template <class T, class Allocator>
const_buffer buffer(const vector<T, Allocator>& data) noexcept;
template <class CharT, class Traits, class Allocator>
mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data) noexcept;
template <class CharT, class Traits, class Allocator>
const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data) noexcept;
template <class CharT, class Traits>
const_buffer buffer(basic_string_view<CharT, Traits> data) noexcept;

template <class T, size_t N>
mutable_buffer buffer(T (&data)[N], size_t n) noexcept;
template <class T, size_t N>
const_buffer buffer(const T (&data)[N], size_t n) noexcept;
template <class T, size_t N>
mutable_buffer buffer(array<T, N>& data, size_t n) noexcept;
template <class T, size_t N>
const_buffer buffer(array<const T, N>& data, size_t n) noexcept;
template <class T, size_t N>
const_buffer buffer(const array<T, N>& data, size_t n) noexcept;
template <class T, class Allocator>
mutable_buffer buffer(vector<T, Allocator>& data, size_t n) noexcept;
template <class T, class Allocator>
const_buffer buffer(const vector<T, Allocator>& data, size_t n) noexcept;
template <class CharT, class Traits, class Allocator>
mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept;
template <class CharT, class Traits, class Allocator>
const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept;
template <class CharT, class Traits>
const_buffer buffer(basic_string_view<CharT, Traits> data, size_t n) noexcept;

template <class T, class Allocator>
class dynamic_vector_buffer;

template <class CharT, class Traits, class Allocator>
class dynamic_string_buffer;

template <class T, class Allocator>
dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec) noexcept;
template <class T, class Allocator>
dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec, size_t n) noexcept;

template <class CharT, class Traits, class Allocator>
dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str) noexcept;
template <class CharT, class Traits, class Allocator>
dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str, size_t n) noexcept;

class transfer_all;
class transfer_at_least;
class transfer_exactly;

template <class SyncReadStream, class MutableBufferSequence>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers);
template <class SyncReadStream, class MutableBufferSequence>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, error_code& ec);
template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition);
template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition>
size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec);

template <class SyncReadStream, class DynamicBuffer>
size_t read(SyncReadStream& stream, DynamicBuffer&& b);
template <class SyncReadStream, class DynamicBuffer>
size_t read(SyncReadStream& stream, DynamicBuffer&& b, error_code& ec);
template <class SyncReadStream, class DynamicBuffer, class CompletionCondition>
size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition);
template <class SyncReadStream, class DynamicBuffer, class CompletionCondition>
size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec);

template <class AsyncReadStream, class MutableBufferSequence, class CompletionToken>
auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionToken&& token);
template <class AsyncReadStream, class MutableBufferSequence, class CompletionCondition, class CompletionToken>
auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);

template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionCondition, class CompletionToken>
auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);

template <class SyncWriteStream, class ConstBufferSequence>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers);
template <class SyncWriteStream, class ConstBufferSequence>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, error_code& ec);
template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition);
template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition>
size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec);

template <class SyncWriteStream, class DynamicBuffer>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b);
template <class SyncWriteStream, class DynamicBuffer>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b, error_code& ec);
template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition);
template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition>
size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec);

template <class AsyncWriteStream, class ConstBufferSequence, class CompletionToken>
auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionToken&& token);
template <class AsyncWriteStream, class ConstBufferSequence, class CompletionCondition, class CompletionToken>
auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);

template <class AsyncWriteStream, class DynamicBuffer, class CompletionToken>
auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionToken&& token);
template <class AsyncWriteStream, class DynamicBuffer, class CompletionCondition, class CompletionToken>
auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);

template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim);
template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim, error_code& ec);
template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim);
template <class SyncReadStream, class DynamicBuffer>
size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim, error_code& ec);

template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, char delim, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, string_view delim, CompletionToken&& token);
} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::stream_errc> : public true_type
{
};
} // namespace std

#endif
