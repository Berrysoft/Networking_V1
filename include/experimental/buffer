#ifndef NET_BUFFER
#define NET_BUFFER

#include <algorithm>
#include <array>
#include <string>
#include <string_view>
#include <system_error>
#include <type_traits>
#include <vector>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class stream_errc
{
    eof = 2,
    not_found = 3
};

struct _Stream_category : error_category
{
    const char* name() const noexcept override { return "stream"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(stream_errc::eof):
            return "End of file";
        case static_cast<int>(stream_errc::not_found):
            return "Element not found";
        default:
            return "stream error";
        }
    }
};

inline const error_category& stream_category() noexcept
{
    static _Stream_category instance{};
    return instance;
}

inline error_code make_error_code(stream_errc e) noexcept { return error_code{ static_cast<int>(e), stream_category() }; }
inline error_condition make_error_condition(stream_errc e) noexcept { return error_condition{ static_cast<int>(e), stream_category() }; }

class mutable_buffer
{
public:
    mutable_buffer() noexcept : data_(nullptr), size_(0) {}
    mutable_buffer(void* p, size_t n) noexcept : data_(p), size_(n) {}

    void* data() const noexcept { return data_; }
    size_t size() const noexcept { return size_; }
    mutable_buffer& operator+=(size_t n) noexcept
    {
        n = min(n, size_);
        data_ = static_cast<char*>(data_) + n;
        size_ -= n;
        return *this;
    }

    friend mutable_buffer operator+(const mutable_buffer& b, size_t n) noexcept
    {
        n = min(n, size_);
        return mutable_buffer{ static_cast<char*>(b.data_) + n, b.size_ - n };
    }
    friend mutable_buffer operator+(size_t n, const mutable_buffer& b) noexcept { return b + n; }

private:
    void* data_;
    size_t size_;

    friend class const_buffer;
};
class const_buffer
{
public:
    const_buffer() noexcept : data_(nullptr), size_(0) {}
    const_buffer(const void* p, size_t n) noexcept : data_(p), size_(n) {}
    const_buffer(const mutable_buffer& b) noexcept : data_(b.data_), size_(b.size_) {}

    const void* data() const noexcept { return data_; }
    size_t size() const noexcept { return size_; }
    const_buffer& operator+=(size_t n) noexcept
    {
        n = min(n, size_);
        data_ = static_cast<const char*>(data_) + n;
        size_ -= n;
        return *this;
    }

    friend const_buffer operator+(const const_buffer& b, size_t n) noexcept
    {
        n = min(n, size_);
        return const_buffer{ static_cast<const char*>(b.data_) + n, b.size_ - n };
    }
    friend const_buffer operator+(size_t n, const const_buffer& b) noexcept { return b + n; }

private:
    const void* data_;
    size_t size_;
};

template <class T, class = void, class = void>
struct is_mutable_buffer_sequence : false_type
{
};
template <class T,
          class = void_t<decltype(buffer_sequence_begin(declval<T>()))>,
          class = void_t<decltype(buffer_sequence_end(declval<T>()))>>
struct is_mutable_buffer_sequence : true_type
{
};

template <class T, class = void, class = void>
struct is_const_buffer_sequence : false_type
{
};
template <class T,
          class = void_t<decltype(buffer_sequence_begin(declval<T>()))>,
          class = void_t<decltype(buffer_sequence_end(declval<T>()))>>
struct is_const_buffer_sequence : true_type
{
};

template <class T, class = void, class = void, class = void, class = void, class = void, class = void, class = void, class = void, class = void>
struct is_dynamic_buffer : false_type
{
};
template <class T,
          class = void_t<typename T::const_buffers_type>,
          class = void_t<typename T::mutable_buffers_type>,
          class = void_t<decltype(declval<T>().size())>,
          class = void_t<decltype(declval<T>().max_size())>,
          class = void_t<decltype(declval<T>().capacity())>,
          class = void_t<decltype(declval<T>().data())>,
          class = void_t<decltype(declval<T>().prepare(0))>,
          class = void_t<decltype(declval<T>().commit(0))>,
          class = void_t<decltype(declval<T>().consume(0))>>
struct is_dynamic_buffer : true_type
{
};

template <class T>
constexpr bool is_mutable_buffer_sequence_v{ is_mutable_buffer_sequence<T>::value };
template <class T>
constexpr bool is_const_buffer_sequence_v{ is_const_buffer_sequence<T>::value };
template <class T>
constexpr bool is_dynamic_buffer_v{ is_dynamic_buffer<T>::value };

inline const mutable_buffer* buffer_sequence_begin(const mutable_buffer& b) noexcept { return addressof(b); }
inline const const_buffer* buffer_sequence_begin(const const_buffer& b) noexcept { return addressof(b); }
inline const mutable_buffer* buffer_sequence_end(const mutable_buffer& b) noexcept { return addressof(b) + 1; }
inline const const_buffer* buffer_sequence_end(const const_buffer& b) noexcept { return addressof(b) + 1; }
template <class C>
inline decltype(auto) buffer_sequence_begin(C& c) noexcept
{
    return c.begin();
}
template <class C>
inline decltype(auto) buffer_sequence_begin(const C& c) noexcept
{
    return c.begin();
}
template <class C>
inline decltype(auto) buffer_sequence_end(C& c) noexcept
{
    return c.end();
}
template <class C>
inline decltype(auto) buffer_sequence_end(const C& c) noexcept
{
    return c.end();
}

template <class ConstBufferSequence>
inline size_t buffer_size(const ConstBufferSequence& buffers) noexcept
{
    size_t total_size{ 0 };
    auto i{ buffer_sequence_begin(buffers) };
    auto end{ buffer_sequence_end(buffers) };
    for (; i != end; ++i)
    {
        const_buffer b{ *i };
        total_size += b.size();
    }
    return total_size;
}
template <class MutableBufferSequence, class ConstBufferSequence>
inline size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source) noexcept;
template <class MutableBufferSequence, class ConstBufferSequence>
inline size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source, size_t max_size) noexcept;

inline mutable_buffer buffer(void* p, size_t n) noexcept { return mutable_buffer{ p, n }; }
inline const_buffer buffer(const void* p, size_t n) noexcept { return const_buffer{ p, n }; }

inline mutable_buffer buffer(const mutable_buffer& b) noexcept { return b; }
inline mutable_buffer buffer(const mutable_buffer& b, size_t n) noexcept { return mutable_buffer{ b.data(), min(n, b.size()) }; }
inline const_buffer buffer(const const_buffer& b) noexcept { return b; }
inline const_buffer buffer(const const_buffer& b, size_t n) noexcept { return const_buffer{ b.data(), min(n, b.size()) }; }

template <class T, size_t N>
inline mutable_buffer buffer(T (&data)[N]) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const T (&data)[N]) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline mutable_buffer buffer(array<T, N>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(array<const T, N>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const array<T, N>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline mutable_buffer buffer(vector<T, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline const_buffer buffer(const vector<T, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits>
inline const_buffer buffer(basic_string_view<CharT, Traits> data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}

template <class T, size_t N>
inline mutable_buffer buffer(T (&data)[N], size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const T (&data)[N], size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline mutable_buffer buffer(array<T, N>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(array<const T, N>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const array<T, N>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline mutable_buffer buffer(vector<T, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline const_buffer buffer(const vector<T, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits>
inline const_buffer buffer(basic_string_view<CharT, Traits> data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}

template <class T, class Allocator>
class dynamic_vector_buffer
{
public:
    using const_buffers_type = const_buffer;
    using mutable_buffers_type = mutable_buffer;

    explicit dynamic_vector_buffer(vector<T, Allocator>& vec) noexcept : vec_(vec), size_(vec.size()), max_size_(vec.max_size()) {}
    dynamic_vector_buffer(vector<T, Allocator>& vec, size_t maximum_size) noexcept : vec_(vec), size_(vec.size()), max_size_(maximum_size) {}
    dynamic_vector_buffer(dynamic_vector_buffer&&) = default;

    size_t size() const noexcept { return size_; }
    size_t max_size() const noexcept { return max_size_; }
    size_t capacity() const noexcept { return vec_.capacity(); }
    const_buffers_type data() const noexcept { return buffer(vec_, size_); }
    mutable_buffers_type prepare(size_t n)
    {
        vec_.resize(size_ + n);
        return buffer(buffer(vec_) + size_, n);
    }
    void commit(size_t n)
    {
        size_ += min(n, vec_.size() - size_);
        vec_.resize(size_);
    }
    void consume(size_t n)
    {
        size_t m = min(n, size_);
        vec_.erase(vec_.begin(), vec_.begin() + m);
        size_ -= m;
    }

private:
    vector<T, Allocator>& vec_;
    size_t size_;
    const size_t max_size_;
};

template <class CharT, class Traits, class Allocator>
class dynamic_string_buffer
{
public:
    using const_buffers_type = const_buffer;
    using mutable_buffers_type = mutable_buffer;

    explicit dynamic_string_buffer(basic_string<CharT, Traits, Allocator>& str) noexcept : str_(str), size_(str.size()), max_size_(str.max_size()) {}
    dynamic_string_buffer(basic_string<CharT, Traits, Allocator>& str, size_t maximum_size) noexcept : str_(str), size_(str.size()), max_size_(maximum_size) {}
    dynamic_string_buffer(dynamic_string_buffer&&) = default;

    size_t size() const noexcept { return size_; }
    size_t max_size() const noexcept { return max_size_; }
    size_t capacity() const noexcept { return str_.capacity(); }
    const_buffers_type data() const noexcept { buffer(str_, size_); }
    mutable_buffers_type prepare(size_t n)
    {
        str_.resize(size_ + n);
        return buffer(buffer(str_) + size_, n);
    }

    void commit(size_t n) noexcept
    {
        size_ += min(n, str_.size() - size_);
        str_.resize(size_);
    }
    void consume(size_t n)
    {
        size_t m = min(n, size_);
        str_.erase(0, m);
        size_ -= m;
    }

private:
    basic_string<CharT, Traits, Allocator>& str_;
    size_t size_;
    const size_t max_size_;
};

template <class T, class Allocator>
inline dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec) noexcept
{
    return dynamic_vector_buffer<T, Allocator>{ vec };
}
template <class T, class Allocator>
inline dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec, size_t n) noexcept
{
    return dynamic_vector_buffer<T, Allocator>{ vec, n };
}

template <class CharT, class Traits, class Allocator>
inline dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str) noexcept
{
    return dynamic_string_buffer<CharT, Traits, Allocator>{ str };
}
template <class CharT, class Traits, class Allocator>
inline dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str, size_t n) noexcept
{
    return dynamic_string_buffer<CharT, Traits, Allocator>{ str, n };
}

constexpr size_t _Default_max_transfer_size{ 65536 };

class transfer_all
{
public:
    size_t operator()(const error_code& ec, size_t) const { return !ec ? _Default_max_transfer_size : 0; }
};

class transfer_at_least
{
public:
    explicit transfer_at_least(size_t m) : minimum_(m) {}
    size_t operator()(const error_code& ec, size_t n) const { return !ec && n < minimum_ ? _Default_max_transfer_size : 0; }

private:
    size_t minimum_;
};

class transfer_exactly
{
public:
    explicit transfer_exactly(size_t e) : exact_(e) {}
    size_t operator()(const error_code& ec, size_t n) const { return !ec && n < exact_ ? min(exact_ - n, _Default_max_transfer_size) : 0; }

private:
    size_t exact_;
};

inline void _Check_error_code(error_code& ec, const char* what)
{
    if (ec)
        throw system_error{ ec, what };
}

template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec);
template <class SyncReadStream, class MutableBufferSequence, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, error_code& ec)
{
    return read(stream, buffers, transfer_all{}, ec);
}
template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition)
{
    error_code ec;
    size_t r{ read(stream, buffers, completion_condition, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
template <class SyncReadStream, class MutableBufferSequence, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers)
{
    error_code ec;
    size_t r{ read(stream, buffers, transfer_all{}, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

template <class SyncReadStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec);
template <class SyncReadStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b, error_code& ec)
{
    return read(stream, forward<DynamicBuffer>(b), transfer_all{}, ec);
}
template <class SyncReadStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition)
{
    error_code ec;
    size_t r{ read(stream, forward<DynamicBuffer>(b), completion_condition, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
template <class SyncReadStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b)
{
    error_code ec;
    size_t r{ read(stream, forward<DynamicBuffer>(b), transfer_all{}, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

template <class AsyncReadStream, class MutableBufferSequence, class CompletionCondition, class CompletionToken, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncReadStream, class MutableBufferSequence, class CompletionToken, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionToken&& token)
{
    return async_read(stream, buffers, transfer_all{}, forward<CompletionToken>(token));
}

template <class AsyncReadStream, class DynamicBuffer, class CompletionCondition, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionToken&& token)
{
    return async_read(stream, forward<DynamicBuffer>(b), transfer_all{}, forward<CompletionToken>(token));
}

template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec);
template <class SyncWriteStream, class ConstBufferSequence, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, error_code& ec)
{
    return write(stream, buffers, transfer_all{}, ec);
}
template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition)
{
    error_code ec;
    size_t r{ write(stream, buffers, completion_condition, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
template <class SyncWriteStream, class ConstBufferSequence, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers)
{
    error_code ec;
    size_t r{ write(stream, buffers, transfer_all{}, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec);
template <class SyncWriteStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b, error_code& ec)
{
    return write(stream, forward<DynamicBuffer>(b), transfer_all{}, ec);
}
template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition)
{
    error_code ec;
    size_t r{ write(stream, forward<DynamicBuffer>(b), completion_condition, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
template <class SyncWriteStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b)
{
    error_code ec;
    size_t r{ write(stream, forward<DynamicBuffer>(b), transfer_all{}, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

template <class AsyncWriteStream, class ConstBufferSequence, class CompletionCondition, class CompletionToken, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncWriteStream, class ConstBufferSequence, class CompletionToken, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionToken&& token)
{
    return async_write(stream, buffers, transfer_all{}, forward<CompletionToken>(token));
}

template <class AsyncWriteStream, class DynamicBuffer, class CompletionCondition, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncWriteStream, class DynamicBuffer, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionToken&& token)
{
    return async_write(stream, forward<DynamicBuffer>(b), transfer_all{}, forward<CompletionToken>(token));
}

template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim, error_code& ec);
template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim)
{
    error_code ec;
    size_t r{ read_until(s, forward<DynamicBuffer>(b), delim, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim, error_code& ec);
template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim)
{
    error_code ec;
    size_t r{ read_until(s, forward<DynamicBuffer>(b), delim, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, char delim, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, string_view delim, CompletionToken&& token);
} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::stream_errc> : public true_type
{
};
} // namespace std

#endif
