#ifndef NET_BUFFER
#define NET_BUFFER

#include <experimental/netfwd>

#include <algorithm>
#include <array>
#include <cstring>
#include <string>
#include <string_view>
#include <system_error>
#include <type_traits>
#include <vector>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class stream_errc
{
    eof = 2,
    not_found = 3
};

struct _Stream_category : error_category
{
    const char* name() const noexcept override { return "stream"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(stream_errc::eof):
            return "End of file";
        case static_cast<int>(stream_errc::not_found):
            return "Element not found";
        default:
            return "stream error";
        }
    }
};

inline const error_category& stream_category() noexcept
{
    static _Stream_category instance{};
    return instance;
}

inline error_code make_error_code(stream_errc e) noexcept { return error_code{ static_cast<int>(e), stream_category() }; }
inline error_condition make_error_condition(stream_errc e) noexcept { return error_condition{ static_cast<int>(e), stream_category() }; }

template <class T>
class _Buffer_base
{
public:
    _Buffer_base() noexcept : data_(nullptr), size_(0) {}
    _Buffer_base(T* p, size_t n) noexcept : data_(p), size_(n) {}

    T* data() const noexcept { return data_; }
    size_t size() const noexcept { return size_; }
    _Buffer_base& operator+=(size_t n) noexcept
    {
        n = min(n, size_);
        data_ = static_cast<char*>(data_) + n;
        size_ -= n;
        return *this;
    }

    friend _Buffer_base operator+(const _Buffer_base& b, size_t n) noexcept
    {
        n = min(n, size_);
        return _Buffer_base{ static_cast<char*>(b.data_) + n, b.size_ - n };
    }
    friend _Buffer_base operator+(size_t n, const _Buffer_base& b) noexcept { return b + n; }

private:
    T* data_;
    size_t size_;
};

class mutable_buffer : public _Buffer_base<void>
{
public:
    using _Buffer_base<void>::_Buffer_base;
};

class const_buffer : public _Buffer_base<const void>
{
public:
    using _Buffer_base<const void>::_Buffer_base;

    const_buffer(const mutable_buffer& b) noexcept : _Buffer_base<const void>(b.data(), b.size()) {}
};

template <class T, class = void, class = void>
struct is_mutable_buffer_sequence : false_type
{
};
template <class T>
struct is_mutable_buffer_sequence<T, void_t<decltype(buffer_sequence_begin(declval<T>()))>, void_t<decltype(buffer_sequence_end(declval<T>()))>> : true_type
{
};

template <class T, class = void, class = void>
struct is_const_buffer_sequence : false_type
{
};
template <class T>
struct is_const_buffer_sequence<T, void_t<decltype(buffer_sequence_begin(declval<T>()))>, void_t<decltype(buffer_sequence_end(declval<T>()))>> : true_type
{
};

template <class T, class = void, class = void, class = void, class = void, class = void, class = void, class = void, class = void, class = void>
struct is_dynamic_buffer : false_type
{
};
template <class T>
struct is_dynamic_buffer<
    T,
    void_t<typename T::const_buffers_type>,
    void_t<typename T::mutable_buffers_type>,
    void_t<decltype(declval<T>().size())>,
    void_t<decltype(declval<T>().max_size())>,
    void_t<decltype(declval<T>().capacity())>,
    void_t<decltype(declval<T>().data())>,
    void_t<decltype(declval<T>().prepare(0))>,
    void_t<decltype(declval<T>().commit(0))>,
    void_t<decltype(declval<T>().consume(0))>> : true_type
{
};

template <class T>
constexpr bool is_mutable_buffer_sequence_v{ is_mutable_buffer_sequence<T>::value };
template <class T>
constexpr bool is_const_buffer_sequence_v{ is_const_buffer_sequence<T>::value };
template <class T>
constexpr bool is_dynamic_buffer_v{ is_dynamic_buffer<T>::value };

inline const mutable_buffer* buffer_sequence_begin(const mutable_buffer& b) noexcept { return addressof(b); }
inline const const_buffer* buffer_sequence_begin(const const_buffer& b) noexcept { return addressof(b); }
inline const mutable_buffer* buffer_sequence_end(const mutable_buffer& b) noexcept { return addressof(b) + 1; }
inline const const_buffer* buffer_sequence_end(const const_buffer& b) noexcept { return addressof(b) + 1; }
template <class C>
inline decltype(auto) buffer_sequence_begin(C& c) noexcept
{
    return c.begin();
}
template <class C>
inline decltype(auto) buffer_sequence_begin(const C& c) noexcept
{
    return c.begin();
}
template <class C>
inline decltype(auto) buffer_sequence_end(C& c) noexcept
{
    return c.end();
}
template <class C>
inline decltype(auto) buffer_sequence_end(const C& c) noexcept
{
    return c.end();
}

template <class ConstBufferSequence>
inline size_t buffer_size(const ConstBufferSequence& buffers) noexcept
{
    size_t total_size{ 0 };
    auto i{ buffer_sequence_begin(buffers) };
    auto end{ buffer_sequence_end(buffers) };
    for (; i != end; ++i)
    {
        const_buffer b{ *i };
        total_size += b.size();
    }
    return total_size;
}
template <class MutableBufferSequence, class ConstBufferSequence>
inline size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source, size_t max_size) noexcept
{
    auto begin1{ buffer_sequence_begin(dest) };
    auto end1{ buffer_sequence_end(dest) };
    auto begin2{ buffer_sequence_begin(source) };
    auto end2{ buffer_sequence_end(source) };
    mutable_buffer d{ *begin1 };
    const_buffer s{ *begin2 };
    size_t r{ 0 };
    while (begin1 != end1 && begin2 != end2 && max_size)
    {
        size_t n{ min({ d.size(), s.size(), max_size }) };
        memcpy(d.data(), s.data(), n);
        if ((!((s += n).size())) && ++begin2)
        {
            s = *begin2;
        }
        if ((!((d += n).size())) && ++begin1)
        {
            d = *begin1;
        }
        max_size -= n;
        r += n;
    }
    return r;
}
template <class MutableBufferSequence, class ConstBufferSequence>
inline size_t buffer_copy(const MutableBufferSequence& dest, const ConstBufferSequence& source) noexcept
{
    return buffer_copy(dest, source, numeric_limits<size_t>::max());
}

inline mutable_buffer buffer(void* p, size_t n) noexcept { return mutable_buffer{ p, n }; }
inline const_buffer buffer(const void* p, size_t n) noexcept { return const_buffer{ p, n }; }

inline mutable_buffer buffer(const mutable_buffer& b) noexcept { return b; }
inline mutable_buffer buffer(const mutable_buffer& b, size_t n) noexcept { return mutable_buffer{ b.data(), min(n, b.size()) }; }
inline const_buffer buffer(const const_buffer& b) noexcept { return b; }
inline const_buffer buffer(const const_buffer& b, size_t n) noexcept { return const_buffer{ b.data(), min(n, b.size()) }; }

template <class T, size_t N>
inline mutable_buffer buffer(T (&data)[N]) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const T (&data)[N]) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline mutable_buffer buffer(array<T, N>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(array<const T, N>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const array<T, N>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline mutable_buffer buffer(vector<T, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline const_buffer buffer(const vector<T, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits>
inline const_buffer buffer(basic_string_view<CharT, Traits> data) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}

template <class T, size_t N>
inline mutable_buffer buffer(T (&data)[N], size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const T (&data)[N], size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline mutable_buffer buffer(array<T, N>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(array<const T, N>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, size_t N>
inline const_buffer buffer(const array<T, N>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline mutable_buffer buffer(vector<T, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class T, class Allocator>
inline const_buffer buffer(const vector<T, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline mutable_buffer buffer(basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits, class Allocator>
inline const_buffer buffer(const basic_string<CharT, Traits, Allocator>& data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}
template <class CharT, class Traits>
inline const_buffer buffer(basic_string_view<CharT, Traits> data, size_t n) noexcept
{
    return buffer(begin(data) != end(data) ? addressof(*begin(data)) : nullptr, (end(data) - begin(data)) * sizeof(*begin(data)));
}

template <class Container>
class _Dynamic_buffer_base
{
public:
    using const_buffers_type = const_buffer;
    using mutable_buffers_type = mutable_buffer;

    explicit _Dynamic_buffer_base(Container& c) noexcept : c_(c), size_(c.size()), max_size_(c.max_size()) {}
    _Dynamic_buffer_base(Container& c, size_t maximum_size) noexcept : c_(c), size_(c.size()), max_size_(maximum_size) {}
    _Dynamic_buffer_base(_Dynamic_buffer_base&&) = default;

    size_t size() const noexcept { return size_; }
    size_t max_size() const noexcept { return max_size_; }
    size_t capacity() const noexcept { return c_.capacity(); }
    const_buffers_type data() const noexcept { return buffer(c_, size_); }
    mutable_buffers_type prepare(size_t n)
    {
        if (size_ + n > max_size_)
            throw length_error{ "size exceeded" };
        c_.resize(size_ + n);
        return buffer(buffer(c_) + size_, n);
    }
    void commit(size_t n)
    {
        size_ += min(n, c_.size() - size_);
        c_.resize(size_);
    }
    void consume(size_t n)
    {
        size_t m = min(n, size_);
        c_.erase(c_.begin(), c_.begin() + m);
        size_ -= m;
    }

private:
    Container& c_;
    size_t size_;
    const size_t max_size_;
};

template <class T, class Allocator>
class dynamic_vector_buffer : public _Dynamic_buffer_base<vector<T, Allocator>>
{
public:
    using _Dynamic_buffer_base<vector<T, Allocator>>::_Dynamic_buffer_base;
};

template <class CharT, class Traits, class Allocator>
class dynamic_string_buffer : public _Dynamic_buffer_base<basic_string<CharT, Traits, Allocator>>
{
public:
    using _Dynamic_buffer_base<basic_string<CharT, Traits, Allocator>>::_Dynamic_buffer_base;
};

template <class T, class Allocator>
inline dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec) noexcept
{
    return dynamic_vector_buffer<T, Allocator>{ vec };
}
template <class T, class Allocator>
inline dynamic_vector_buffer<T, Allocator> dynamic_buffer(vector<T, Allocator>& vec, size_t n) noexcept
{
    return dynamic_vector_buffer<T, Allocator>{ vec, n };
}

template <class CharT, class Traits, class Allocator>
inline dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str) noexcept
{
    return dynamic_string_buffer<CharT, Traits, Allocator>{ str };
}
template <class CharT, class Traits, class Allocator>
inline dynamic_string_buffer<CharT, Traits, Allocator> dynamic_buffer(basic_string<CharT, Traits, Allocator>& str, size_t n) noexcept
{
    return dynamic_string_buffer<CharT, Traits, Allocator>{ str, n };
}

constexpr size_t _Default_max_transfer_size{ 65536 };

class transfer_all
{
public:
    size_t operator()(const error_code& ec, size_t) const { return !ec ? _Default_max_transfer_size : 0; }
};

class transfer_at_least
{
public:
    explicit transfer_at_least(size_t m) : minimum_(m) {}
    size_t operator()(const error_code& ec, size_t n) const { return !ec && n < minimum_ ? _Default_max_transfer_size : 0; }

private:
    size_t minimum_;
};

class transfer_exactly
{
public:
    explicit transfer_exactly(size_t e) : exact_(e) {}
    size_t operator()(const error_code& ec, size_t n) const { return !ec && n < exact_ ? min(exact_ - n, _Default_max_transfer_size) : 0; }

private:
    size_t exact_;
};

template <class Buffers>
struct _Prepared_buffers_max
{
    static constexpr size_t value{ 64 };
};
template <class Elem, size_t N>
struct _Prepared_buffers_max<array<Elem, N>>
{
    static constexpr size_t value{ N };
};

template <class Buffers>
constexpr size_t _Prepared_buffers_max_v{ _Prepared_buffers_max<Buffers>::value };

template <class Buffer, size_t MaxBuffers>
struct _Prepared_buffers
{
    using value_type = Buffer;
    using const_iterator = const Buffer*;

    static constexpr size_t max_buffers{ MaxBuffers < 16 ? MaxBuffers : 16 };

    _Prepared_buffers() : count(0) {}
    const_iterator begin() const { return elems; }
    const_iterator end() const { return elems + count; }

    Buffer elems[max_buffers];
    size_t count;
};

template <class Buffer, class Buffers>
class _Consuming_buffers
{
public:
    using prepared_buffers_type = _Prepared_buffers<Buffer, _Prepared_buffers_max_v<Buffers>>;

    explicit _Consuming_buffers(const Buffers& buffers)
        : buffers_(buffers), total_consumed_(0), next_elem_(0), next_elem_offset_(0)
    {
        total_size_ = buffer_size(buffers);
    }

    bool empty() const { return total_consumed_ >= total_size_; }

    prepared_buffers_type prepare(size_t max_size)
    {
        prepared_buffers_type result;
        auto next{ buffer_sequence_begin(buffers_) };
        auto end{ buffer_sequence_end(buffers_) };
        advance(next, next_elem_);
        size_t elem_offset{ next_elem_offset_ };
        while (next != end && max_size > 0 && result.count < result.max_buffers)
        {
            Buffer next_buf{ Buffer{ *next } + elem_offset };
            result.elems[result.count] = buffer(next_buf, max_size);
            max_size -= result.elems[result.count].size();
            elem_offset = 0;
            if (result.elems[result.count].size() > 0)
                ++result.count;
            ++next;
        }
        return result;
    }

    void consume(size_t size)
    {
        total_consumed_ += size;
        auto next{ buffer_sequence_begin(buffers_) };
        auto end{ buffer_sequence_end(buffers_) };
        advance(next, next_elem_);
        while (next != end && size > 0)
        {
            Buffer next_buf{ Buffer{ *next } + next_elem_offset_ };
            if (size < next_buf.size())
            {
                next_elem_offset_ += size;
                size = 0;
            }
            else
            {
                size -= next_buf.size();
                next_elem_offset_ = 0;
                ++next_elem_;
                ++next;
            }
        }
    }

    size_t total_consumed() const { return total_consumed_; }

private:
    Buffers buffers_;
    size_t total_size_;
    size_t total_consumed_;
    size_t next_elem_;
    size_t next_elem_offset_;
};

template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec)
{
    ec = error_code{};
    _Consuming_buffers<mutable_buffer, MutableBufferSequence> tmp{ buffers };
    while (!tmp.empty())
    {
        if (size_t max_size{ completion_condition(ec, tmp.total_consumed()) })
        {
            tmp.consume(stream.read_some(tmp.prepare(max_size), ec));
        }
        else
        {
            break;
        }
    }
    return tmp.total_consumed();
}
template <class SyncReadStream, class MutableBufferSequence, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, error_code& ec)
{
    return read(stream, buffers, transfer_all{}, ec);
}
template <class SyncReadStream, class MutableBufferSequence, class CompletionCondition, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(read(stream, buffers, completion_condition, ec));
}
template <class SyncReadStream, class MutableBufferSequence, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline size_t read(SyncReadStream& stream, const MutableBufferSequence& buffers)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(read(stream, buffers, transfer_all{}, ec));
}

template <class SyncReadStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec)
{
    decay_t<DynamicBuffer> buffer{ forward<DynamicBuffer>(b) };
    ec = error_code{};
    size_t total_transferred{ 0 };
    size_t max_size{ completion_condition(ec, total_transferred) };
    size_t bytes_available{ min(max(512, buffer.capacity() - buffer.size()), min(max_size, buffer.max_size() - buffer.size())) };
    while (bytes_available > 0)
    {
        size_t bytes_transferred{ stream.read_some(buffer.prepare(bytes_available), ec) };
        buffer.commit(bytes_transferred);
        total_transferred += bytes_transferred;
        max_size = completion_condition(ec, total_transferred);
        bytes_available = min(max(512, buffer.capacity() - buffer.size()), min(max_size, buffer.max_size() - buffer.size()));
    }
    return total_transferred;
}
template <class SyncReadStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b, error_code& ec)
{
    return read(stream, forward<DynamicBuffer>(b), transfer_all{}, ec);
}
template <class SyncReadStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(read(stream, forward<DynamicBuffer>(b), completion_condition, ec));
}
template <class SyncReadStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t read(SyncReadStream& stream, DynamicBuffer&& b)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(read(stream, forward<DynamicBuffer>(b), transfer_all{}, ec));
}

template <class AsyncReadStream, class MutableBufferSequence, class CompletionCondition, class CompletionToken, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncReadStream, class MutableBufferSequence, class CompletionToken, class = enable_if_t<is_mutable_buffer_sequence_v<MutableBufferSequence>>>
inline auto async_read(AsyncReadStream& stream, const MutableBufferSequence& buffers, CompletionToken&& token)
{
    return async_read(stream, buffers, transfer_all{}, forward<CompletionToken>(token));
}

template <class AsyncReadStream, class DynamicBuffer, class CompletionCondition, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_read(AsyncReadStream& stream, DynamicBuffer&& b, CompletionToken&& token)
{
    return async_read(stream, forward<DynamicBuffer>(b), transfer_all{}, forward<CompletionToken>(token));
}

template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, error_code& ec)
{
    ec = error_code{};
    _Consuming_buffers<const_buffer, ConstBufferSequence> tmp{ buffers };
    while (!tmp.empty())
    {
        if (size_t max_size{ completion_condition(ec, tmp.total_consumed()) })
        {
            tmp.consume(stream.write_some(tmp.prepare(max_size), ec));
        }
        else
        {
            break;
        }
    }
    return tmp.total_consumed();
}
template <class SyncWriteStream, class ConstBufferSequence, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, error_code& ec)
{
    return write(stream, buffers, transfer_all{}, ec);
}
template <class SyncWriteStream, class ConstBufferSequence, class CompletionCondition, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(write(stream, buffers, completion_condition, ec));
}
template <class SyncWriteStream, class ConstBufferSequence, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline size_t write(SyncWriteStream& stream, const ConstBufferSequence& buffers)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(write(stream, buffers, transfer_all{}, ec));
}

template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, error_code& ec)
{
    decay_t<DynamicBuffer> buffer{ forward<DynamicBuffer>(b) };
    size_t bytes_transferred{ write(stream, buffer.data(), completion_condition, ec) };
    buffer.consume(bytes_transferred);
    return bytes_transferred;
}
template <class SyncWriteStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b, error_code& ec)
{
    return write(stream, forward<DynamicBuffer>(b), transfer_all{}, ec);
}
template <class SyncWriteStream, class DynamicBuffer, class CompletionCondition, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(write(stream, forward<DynamicBuffer>(b), completion_condition, ec));
}
template <class SyncWriteStream, class DynamicBuffer, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline size_t write(SyncWriteStream& stream, DynamicBuffer&& b)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(write(stream, forward<DynamicBuffer>(b), transfer_all{}, ec));
}

template <class AsyncWriteStream, class ConstBufferSequence, class CompletionCondition, class CompletionToken, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncWriteStream, class ConstBufferSequence, class CompletionToken, class = enable_if_t<is_const_buffer_sequence_v<ConstBufferSequence>>>
inline auto async_write(AsyncWriteStream& stream, const ConstBufferSequence& buffers, CompletionToken&& token)
{
    return async_write(stream, buffers, transfer_all{}, forward<CompletionToken>(token));
}

template <class AsyncWriteStream, class DynamicBuffer, class CompletionCondition, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionCondition completion_condition, CompletionToken&& token);
template <class AsyncWriteStream, class DynamicBuffer, class CompletionToken, class = enable_if_t<is_dynamic_buffer_v<DynamicBuffer>>>
inline auto async_write(AsyncWriteStream& stream, DynamicBuffer&& b, CompletionToken&& token)
{
    return async_write(stream, forward<DynamicBuffer>(b), transfer_all{}, forward<CompletionToken>(token));
}

template <bool IsMutable>
struct _Buffers_iterator_types_helper;

template <>
struct _Buffers_iterator_types_helper<false>
{
    using buffer_type = const_buffer;
    template <class ByteType>
    using byte_type = add_const_t<ByteType>;
};

template <>
struct _Buffers_iterator_types_helper<true>
{
    using buffer_type = mutable_buffer;
    template <class ByteType>
    using byte_type = ByteType;
};

template <class BufferSequence, class ByteType>
struct _Buffers_iterator_types
{
    static constexpr bool is_mutable{ is_convertible_v<typename BufferSequence::value_type, mutable_buffer> };
    using helper = _Buffers_iterator_types_helper<is_mutable>;
    using buffer_type = typename helper::buffer_type;
    using byte_type = typename helper::byte_type;
    using const_iterator = typename BufferSequence::const_iterator;
};

template <class ByteType>
struct _Buffers_iterator_types<mutable_buffer, ByteType>
{
    using buffer_type = mutable_buffer;
    using byte_type = ByteType;
    using const_iterator = const mutable_buffer*;
};

template <class ByteType>
struct _Buffers_iterator_types<const_buffer, ByteType>
{
    using buffer_type = const_buffer;
    using byte_type = ByteType;
    using const_iterator = const const_buffer*;
};

template <class BufferSequence, class ByteType = char>
class _Buffers_iterator
{
private:
    using types_helper = _Buffers_iterator_types<BufferSequence, ByteType>;
    using buffer_type = typename types_helper::buffer_type;
    using buffer_sequence_iterator_type = typename types_helper::const_iterator;

public:
    using difference_type = ptrdiff_t;
    using value_type = ByteType;
    using pointer = typename types_helper::byte_type*;
    using reference = typename types_helper::byte_type&;
    using iterator_category = random_access_iterator_tag;

    _Buffers_iterator() : current_buffer_(), current_buffer_position_(0), begin_(), current_(), end_(), position_(0) {}

    static _Buffers_iterator begin(const BufferSequence& buffers)
    {
        _Buffers_iterator new_iter{};
        new_iter.begin_ = buffer_sequence_begin(buffers);
        new_iter.current_ = buffer_sequence_begin(buffers);
        new_iter.end_ = buffer_sequence_end(buffers);
        while (new_iter.current_ != new_iter.end_)
        {
            new_iter.current_buffer_ = *new_iter.current_;
            if (new_iter.current_buffer_.size() > 0)
                break;
            ++new_iter.current_;
        }
        return new_iter;
    }
    static _Buffers_iterator end(const BufferSequence& buffers)
    {
        _Buffers_iterator new_iter;
        new_iter.begin_ = buffer_sequence_begin(buffers);
        new_iter.current_ = buffer_sequence_begin(buffers);
        new_iter.end_ = buffer_sequence_end(buffers);
        while (new_iter.current_ != new_iter.end_)
        {
            buffer_type buffer{ *new_iter.current_ };
            new_iter.position_ += buffer.size();
            ++new_iter.current_;
        }
        return new_iter;
    }

    reference operator*() const { return dereference(); }
    pointer operator->() const { return addressof(dereference()); }
    reference operator[](ptrdiff_t difference) const
    {
        _Buffers_iterator tmp{ *this };
        tmp.advance(difference);
        return *tmp;
    }

    _Buffers_iterator& operator++()
    {
        increment();
        return *this;
    }
    _Buffers_iterator operator++(int)
    {
        _Buffers_iterator tmp{ *this };
        ++(*this);
        return tmp;
    }

    _Buffers_iterator& operator--()
    {
        decrement();
        return *this;
    }
    _Buffers_iterator operator--(int)
    {
        _Buffers_iterator tmp{ *this };
        --(*this);
        return tmp;
    }

    _Buffers_iterator& operator+=(ptrdiff_t difference)
    {
        advance(difference);
        return *this;
    }
    _Buffers_iterator& operator-=(ptrdiff_t difference)
    {
        advance(-difference);
        return *this;
    }

    friend _Buffers_iterator operator+(const _Buffers_iterator& iter, ptrdiff_t difference)
    {
        _Buffers_iterator tmp{ iter };
        tmp.advance(difference);
        return tmp;
    }
    friend _Buffers_iterator operator+(ptrdiff_t difference, const _Buffers_iterator& iter)
    {
        _Buffers_iterator tmp{ iter };
        tmp.advance(difference);
        return tmp;
    }
    friend _Buffers_iterator operator-(const _Buffers_iterator& iter, ptrdiff_t difference)
    {
        _Buffers_iterator tmp{ iter };
        tmp.advance(-difference);
        return tmp;
    }
    friend ptrdiff_t operator-(const _Buffers_iterator& a, const _Buffers_iterator& b) { return b.distance_to(a); }

    friend bool operator==(const _Buffers_iterator& a, const _Buffers_iterator& b) { return a.equal(b); }
    friend bool operator!=(const _Buffers_iterator& a, const _Buffers_iterator& b) { return !a.equal(b); }

    friend bool operator<(const _Buffers_iterator& a, const _Buffers_iterator& b) { return a.distance_to(b) > 0; }
    friend bool operator<=(const _Buffers_iterator& a, const _Buffers_iterator& b) { return !(b < a); }
    friend bool operator>(const _Buffers_iterator& a, const _Buffers_iterator& b) { return b < a; }
    friend bool operator>=(const _Buffers_iterator& a, const _Buffers_iterator& b) { return !(a < b); }

private:
    reference dereference() const { return static_cast<pointer>(current_buffer_.data())[current_buffer_position_]; }
    bool equal(const _Buffers_iterator& other) const { return position_ == other.position_; }
    void increment()
    {
        ++position_;
        ++current_buffer_position_;
        if (current_buffer_position_ != current_buffer_.size())
            return;
        ++current_;
        current_buffer_position_ = 0;
        while (current_ != end_)
        {
            current_buffer_ = *current_;
            if (current_buffer_.size() > 0)
                return;
            ++current_;
        }
    }
    void decrement()
    {
        --position_;
        if (current_buffer_position_ != 0)
        {
            --current_buffer_position_;
            return;
        }
        buffer_sequence_iterator_type iter{ current_ };
        while (iter != begin_)
        {
            --iter;
            buffer_type buffer = *iter;
            size_t buffer_size{ buffer.size() };
            if (buffer_size > 0)
            {
                current_ = iter;
                current_buffer_ = buffer;
                current_buffer_position_ = buffer_size - 1;
                return;
            }
        }
    }
    void advance(ptrdiff_t n)
    {
        if (n > 0)
        {
            while (true)
            {
                ptrdiff_t current_buffer_balance{ current_buffer_.size() - current_buffer_position_ };
                if (current_buffer_balance > n)
                {
                    position_ += n;
                    current_buffer_position_ += n;
                    return;
                }
                n -= current_buffer_balance;
                position_ += current_buffer_balance;
                if (++current_ == end_)
                {
                    current_buffer_ = buffer_type();
                    current_buffer_position_ = 0;
                    return;
                }
                current_buffer_ = *current_;
                current_buffer_position_ = 0;
            }
        }
        else if (n < 0)
        {
            size_t abs_n{ -n };
            while (true)
            {
                if (current_buffer_position_ >= abs_n)
                {
                    position_ -= abs_n;
                    current_buffer_position_ -= abs_n;
                    return;
                }
                abs_n -= current_buffer_position_;
                position_ -= current_buffer_position_;
                if (current_ == begin_)
                {
                    current_buffer_position_ = 0;
                    return;
                }
                buffer_sequence_iterator_type iter{ current_ };
                while (iter != begin_)
                {
                    --iter;
                    buffer_type buffer{ *iter };
                    size_t buffer_size{ buffer.size() };
                    if (buffer_size > 0)
                    {
                        current_ = iter;
                        current_buffer_ = buffer;
                        current_buffer_position_ = buffer_size;
                        break;
                    }
                }
            }
        }
    }
    ptrdiff_t distance_to(const _Buffers_iterator& other) const { return other.position_ - position_; }

    buffer_type current_buffer_;
    size_t current_buffer_position_;
    buffer_sequence_iterator_type begin_, current_, end_;
    size_t position_;
};

template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim, error_code& ec)
{
    decay_t<DynamicBuffer> buffer{ forward<DynamicBuffer>(b) };
    size_t search_position{ 0 };
    while (true)
    {
        using buffers_type = typename DynamicBuffer::const_buffers_type;
        using iterator = _Buffers_iterator<buffers_type>;
        buffers_type data_buffers{ buffer.data() };
        iterator begin{ iterator::begin(data_buffers) };
        iterator start_pos{ begin + search_position };
        iterator end{ iterator::end(data_buffers) };
        iterator iter = find(start_pos, end, delim);
        if (iter != end)
        {
            ec = error_code{};
            return iter - begin + 1;
        }
        else
        {
            search_position = end - begin;
        }
        if (buffer.size() == buffer.max_size())
        {
            ec = stream_errc::not_found;
            return 0;
        }
        size_t bytes_to_read{ min(max(512, buffer.capacity() - buffer.size()), min(65536, buffer.max_size() - buffer.size())) };
        buffer.commit(s.read_some(buffer.prepare(bytes_to_read), ec));
        if (ec)
            return 0;
    }
}
template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, char delim)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(read_until(s, forward<DynamicBuffer>(b), delim, ec));
}

template <typename Iterator1, typename Iterator2>
pair<Iterator1, bool> _Partial_search(Iterator1 first1, Iterator1 last1, Iterator2 first2, Iterator2 last2)
{
    for (Iterator1 iter1{ first1 }; iter1 != last1; ++iter1)
    {
        Iterator1 test_iter1{ iter1 };
        Iterator2 test_iter2{ first2 };
        for (;; ++test_iter1, ++test_iter2)
        {
            if (test_iter2 == last2)
                return make_pair(iter1, true);
            if (test_iter1 == last1)
            {
                if (test_iter2 != first2)
                    return make_pair(iter1, false);
                else
                    break;
            }
            if (*test_iter1 != *test_iter2)
                break;
        }
    }
    return make_pair(last1, false);
}

template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim, error_code& ec)
{
    decay_t<DynamicBuffer> buffer{ forward<DynamicBuffer>(b) };
    size_t search_position{ 0 };
    while (true)
    {
        using buffers_type = typename DynamicBuffer::const_buffers_type;
        using iterator = _Buffers_iterator<buffers_type>;
        buffers_type data_buffers{ buffer.data() };
        iterator begin{ iterator::begin(data_buffers) };
        iterator start_pos{ begin + search_position };
        iterator end{ iterator::end(data_buffers) };
        pair<iterator, bool> result = _Partial_search(start_pos, end, delim.begin(), delim.end());
        if (result.first != end)
        {
            if (result.second)
            {
                ec = error_code{};
                return result.first - begin + delim.length();
            }
            else
            {
                search_position = result.first - begin;
            }
        }
        else
        {
            search_position = end - begin;
        }
        if (buffer.size() == buffer.max_size())
        {
            ec = stream_errc::not_found;
            return 0;
        }
        size_t bytes_to_read{ min(max(512, buffer.capacity() - buffer.size()), min(65536, buffer.max_size() - buffer.size())) };
        buffer.commit(s.read_some(buffer.prepare(bytes_to_read), ec));
        if (ec)
            return 0;
    }
}
template <class SyncReadStream, class DynamicBuffer>
inline size_t read_until(SyncReadStream& s, DynamicBuffer&& b, string_view delim)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(read_until(s, forward<DynamicBuffer>(b), delim, ec));
}

template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, char delim, CompletionToken&& token);
template <class AsyncReadStream, class DynamicBuffer, class CompletionToken>
auto async_read_until(AsyncReadStream& s, DynamicBuffer&& b, string_view delim, CompletionToken&& token);
} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::stream_errc> : public true_type
{
};
} // namespace std

#endif
