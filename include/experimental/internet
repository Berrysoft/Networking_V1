#ifndef NET_INTERNET
#define NET_INTERNET

#include <experimental/io_context>
#include <experimental/socket>

#include <WinSock2.h>
#include <Ws2tcpip.h>
#include <algorithm>
#include <array>
#include <cstring>
#include <functional>
#include <sstream>
#include <string>
#include <string_view>
#include <system_error>
#include <type_traits>
#include <vector>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
namespace ip
{
enum class resolver_errc
{
    host_not_found = EAI_NONAME,
    try_again = EAI_AGAIN,
    service_not_found = EAI_SERVICE
};

struct _Resolver_category : error_category
{
    const char* name() const noexcept override { return "resolver"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(resolver_errc::host_not_found):
            return "Host not found";
        case static_cast<int>(resolver_errc::try_again):
            return "Try again later";
        case static_cast<int>(resolver_errc::service_not_found):
            return "Service not found";
        default:
            return "resolver error";
        }
    }
};

inline const error_category& resolver_category() noexcept
{
    static _Resolver_category instance{};
    return instance;
}

inline error_code make_error_code(resolver_errc e) noexcept { return error_code{ static_cast<int>(e), resolver_category() }; }
inline error_condition make_error_condition(resolver_errc e) noexcept { return error_condition{ static_cast<int>(e), resolver_category() }; }

using port_type = uint_least16_t;
using scope_id_type = uint_least32_t;

struct v4_mapped_t
{
};
constexpr v4_mapped_t v4_mapped{};

struct bad_address_cast : bad_cast
{
    bad_address_cast() noexcept : bad_cast() {}
};

class address_v4
{
public:
    using uint_type = uint_least32_t;
    struct bytes_type : array<unsigned char, 4>
    {
        template <class... T>
        explicit constexpr bytes_type(T... t) : array<unsigned char, 4>{ static_cast<unsigned char>(t)... }
        {
        }
    };

    constexpr address_v4() noexcept : addr_() { addr_.s_addr = 0; }
    constexpr address_v4(const address_v4& a) noexcept : addr_(a.addr_) {}
    constexpr address_v4(const bytes_type& bytes) : addr_() { memcpy(&addr_.s_addr, bytes.data(), 4); }
    explicit constexpr address_v4(uint_type val) : addr_() { addr_.s_addr = ::htonl(val); }
    constexpr address_v4(::in_addr val) : addr_(val) {}

    address_v4& operator=(const address_v4& a) noexcept
    {
        addr_ = a.addr_;
        return *this;
    }

    constexpr bytes_type to_bytes() const noexcept
    {
        bytes_type bytes{};
        memcpy(bytes.data(), &addr_.s_addr, 4);
        return bytes;
    }
    constexpr uint_type to_uint() const noexcept { return ::ntohl(addr_.s_addr); }
    constexpr ::in_addr& _Addr() noexcept { return addr_; }
    constexpr const ::in_addr& _Addr() const noexcept { return addr_; }

    constexpr bool is_unspecified() const noexcept { return to_uint() == 0; }
    constexpr bool is_loopback() const noexcept { return (to_uint() & 0xFF000000) == 0x7F000000; }
    constexpr bool is_multicast() const noexcept { return (to_uint() & 0xF0000000) == 0xE0000000; }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        char addr_str[256];
        const char* r{ ::inet_ntop(AF_INET, &addr_, addr_str, 256) };
        if (r)
            return basic_string{ r, a };
        else
            return basic_string<char>{ a };
    }

    static constexpr address_v4 any() noexcept { return address_v4{}; }
    static constexpr address_v4 loopback() noexcept { return address_v4{ 0x7F000001 }; }
    static constexpr address_v4 broadcast() noexcept { return address_v4{ 0xFFFFFFFF }; }

    friend constexpr bool operator==(const address_v4& a, const address_v4& b) noexcept { return a.addr_.s_addr == b.addr_.s_addr; }
    friend constexpr bool operator!=(const address_v4& a, const address_v4& b) noexcept { return !(a == b); }
    friend constexpr bool operator<(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() < b.to_uint(); }
    friend constexpr bool operator>(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() > b.to_uint(); }
    friend constexpr bool operator<=(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() <= b.to_uint(); }
    friend constexpr bool operator>=(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() >= b.to_uint(); }

private:
    ::in_addr addr_;
};

template <class CharT, class Traits>
inline basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const address_v4& a)
{
    return s << a.to_string().c_str();
}

constexpr address_v4 make_address_v4(const address_v4::bytes_type& bytes) { return address_v4{ bytes }; }
constexpr address_v4 make_address_v4(address_v4::uint_type val) { return address_v4{ val }; }
constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6& a)
{
    if (!a.is_v4_mapped())
        throw bad_address_cast{};
    address_v6::bytes_type v6b{ a.to_bytes() };
    address_v4::bytes_type v4b{ v6b[12], v6b[13], v6b[14], v6b[15] };
    return address_v4{ v4b };
}
address_v4 make_address_v4(const char*, error_code&) noexcept;
inline address_v4 make_address_v4(const char* str) { _CHECK_ERROR_CODE_INVOKE_FUNC(make_address_v4(str, ec)); }
inline address_v4 make_address_v4(const string& str, error_code& ec) noexcept { return make_address_v4(str.c_str(), ec); }
inline address_v4 make_address_v4(const string& str) { return make_address_v4(str.c_str()); }
inline address_v4 make_address_v4(string_view str, error_code& ec) noexcept { return make_address_v4(static_cast<string>(str), ec); }
inline address_v4 make_address_v4(string_view str) { return make_address_v4(static_cast<string>(str)); }

class address_v6
{
public:
    struct bytes_type : array<unsigned char, 16>
    {
        template <class... T>
        explicit constexpr bytes_type(T... t) : array<unsigned char, 16>{ static_cast<unsigned char>(t)... }
        {
        }
    };
    constexpr address_v6() noexcept : addr_(), scope_id_(0) {}
    constexpr address_v6(const address_v6& a) noexcept : addr_(a.addr_), scope_id_(a.scope_id_) {}
    constexpr address_v6(const bytes_type& bytes, scope_id_type scope = 0) : addr_(), scope_id_(scope) { memcpy(addr_.s6_addr, bytes.data(), 16); }
    constexpr address_v6(::in6_addr addr, scope_id_type scope) : addr_(addr), scope_id_(scope) {}

    address_v6& operator=(const address_v6& a) noexcept
    {
        addr_ = a.addr_;
        scope_id_ = a.scope_id_;
        return *this;
    }

    constexpr bytes_type to_bytes() const noexcept
    {
        bytes_type bytes;
        memcpy(bytes.data(), addr_.s6_addr, 16);
        return bytes;
    }
    constexpr ::in6_addr& _Addr() noexcept { return addr_; }
    constexpr const ::in6_addr& _Addr() const noexcept { return addr_; }

    void scope_id(scope_id_type id) noexcept { scope_id_ = id; }
    constexpr scope_id_type scope_id() const noexcept { return scope_id_; }
    constexpr bool is_unspecified() const noexcept
    {
        return (addr_.s6_addr[0] == 0) &&
               (addr_.s6_addr[1] == 0) &&
               (addr_.s6_addr[2] == 0) &&
               (addr_.s6_addr[3] == 0) &&
               (addr_.s6_addr[4] == 0) &&
               (addr_.s6_addr[5] == 0) &&
               (addr_.s6_addr[6] == 0) &&
               (addr_.s6_addr[7] == 0) &&
               (addr_.s6_addr[8] == 0) &&
               (addr_.s6_addr[9] == 0) &&
               (addr_.s6_addr[10] == 0) &&
               (addr_.s6_addr[11] == 0) &&
               (addr_.s6_addr[12] == 0) &&
               (addr_.s6_addr[13] == 0) &&
               (addr_.s6_addr[14] == 0) &&
               (addr_.s6_addr[15] == 0);
    }
    constexpr bool is_loopback() const noexcept
    {
        return (addr_.s6_addr[0] == 0) &&
               (addr_.s6_addr[1] == 0) &&
               (addr_.s6_addr[2] == 0) &&
               (addr_.s6_addr[3] == 0) &&
               (addr_.s6_addr[4] == 0) &&
               (addr_.s6_addr[5] == 0) &&
               (addr_.s6_addr[6] == 0) &&
               (addr_.s6_addr[7] == 0) &&
               (addr_.s6_addr[8] == 0) &&
               (addr_.s6_addr[9] == 0) &&
               (addr_.s6_addr[10] == 0) &&
               (addr_.s6_addr[11] == 0) &&
               (addr_.s6_addr[12] == 0) &&
               (addr_.s6_addr[13] == 0) &&
               (addr_.s6_addr[14] == 0) &&
               (addr_.s6_addr[15] == 1);
    }
    constexpr bool is_multicast() const noexcept { return (addr_.s6_addr[0] == 0xff); }
    constexpr bool is_link_local() const noexcept { return (addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0x80); }
    constexpr bool is_site_local() const noexcept { return (addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0xc0); }
    constexpr bool is_v4_mapped() const noexcept
    {
        return (addr_.s6_addr[0] == 0) &&
               (addr_.s6_addr[1] == 0) &&
               (addr_.s6_addr[2] == 0) &&
               (addr_.s6_addr[3] == 0) &&
               (addr_.s6_addr[4] == 0) &&
               (addr_.s6_addr[5] == 0) &&
               (addr_.s6_addr[6] == 0) &&
               (addr_.s6_addr[7] == 0) &&
               (addr_.s6_addr[8] == 0) &&
               (addr_.s6_addr[9] == 0) &&
               (addr_.s6_addr[10] == 0xff) &&
               (addr_.s6_addr[11] == 0xff);
    }
    constexpr bool is_multicast_node_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x01); }
    constexpr bool is_multicast_link_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x02); }
    constexpr bool is_multicast_site_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x05); }
    constexpr bool is_multicast_org_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x08); }
    constexpr bool is_multicast_global() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x0e); }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        char addr_str[256];
        const char* r{ ::inet_ntop(AF_INET6, &addr_, addr_str, 256) };
        if (r)
            return basic_string{ r, a };
        else
            return basic_string<char>{ a };
    }

    static constexpr address_v6 any() noexcept { return address_v6{}; }
    static constexpr address_v6 loopback() noexcept
    {
        address_v6 tmp;
        tmp.addr_.s6_addr[15] = 1;
        return tmp;
    }

    friend constexpr bool operator==(const address_v6& a, const address_v6& b) noexcept
    {
        return memcmp(&a.addr_, &b.addr_, sizeof(::in6_addr)) == 0 && a.scope_id_ == b.scope_id_;
    }
    friend constexpr bool operator!=(const address_v6& a, const address_v6& b) noexcept { return !(a == b); }
    friend constexpr bool operator<(const address_v6& a, const address_v6& b) noexcept
    {
        int memcmp_result = memcmp(&a.addr_, &b.addr_, sizeof(::in6_addr));
        if (memcmp_result < 0)
            return true;
        if (memcmp_result > 0)
            return false;
        return a.scope_id_ < b.scope_id_;
    }
    friend constexpr bool operator>(const address_v6& a, const address_v6& b) noexcept { return b < a; }
    friend constexpr bool operator<=(const address_v6& a, const address_v6& b) noexcept { return !(b < a); }
    friend constexpr bool operator>=(const address_v6& a, const address_v6& b) noexcept { return !(a < b); }

private:
    ::in6_addr addr_;
    scope_id_type scope_id_;
};

template <class CharT, class Traits>
inline basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const address_v6& a)
{
    return s << a.to_string().c_str();
}

constexpr address_v6 make_address_v6(const address_v6::bytes_type& bytes, scope_id_type scope = 0) { return address_v6{ bytes, scope }; }
constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4& a) noexcept
{
    address_v4::bytes_type v4b{ a.to_bytes() };
    address_v6::bytes_type v6b{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, v4b[0], v4b[1], v4b[2], v4b[3] };
    return address_v6{ v6b };
}
address_v6 make_address_v6(const char*, error_code&) noexcept;
inline address_v6 make_address_v6(const char* str) { _CHECK_ERROR_CODE_INVOKE_FUNC(make_address_v6(str, ec)); }
inline address_v6 make_address_v6(const string& str, error_code& ec) noexcept { return make_address_v6(str.c_str(), ec); }
inline address_v6 make_address_v6(const string& str) { return make_address_v6(str.c_str()); }
inline address_v6 make_address_v6(string_view str, error_code& ec) noexcept { return make_address_v6(static_cast<string>(str), ec); }
inline address_v6 make_address_v6(string_view str) { return make_address_v6(static_cast<string>(str)); }

class address
{
public:
    constexpr address() noexcept : type_(ipv4), v4_(), v6_() {}
    constexpr address(const address& a) noexcept : type_(a.type_), v4_(a.v4_), v6_(a.v6_) {}
    constexpr address(const address_v4& a) noexcept : type_(ipv4), v4_(a), v6_() {}
    constexpr address(const address_v6& a) noexcept : type_(ipv6), v4_(), v6_(a) {}

    address& operator=(const address& a) noexcept
    {
        type_ = a.type_;
        v4_ = a.v4_;
        v6_ = a.v6_;
        return *this;
    }
    address& operator=(const address_v4& a) noexcept
    {
        type_ = ipv4;
        v4_ = a;
        v6_ = {};
        return *this;
    }
    address& operator=(const address_v6& a) noexcept
    {
        type_ = ipv6;
        v4_ = {};
        v6_ = a;
        return *this;
    }

    constexpr bool is_v4() const noexcept { return type_ == ipv4; }
    constexpr bool is_v6() const noexcept { return type_ == ipv6; }
    constexpr address_v4 to_v4() const
    {
        if (type_ != ipv4)
            throw bad_address_cast{};
        else
            return v4_;
    }
    constexpr address_v6 to_v6() const
    {
        if (type_ != ipv6)
            throw bad_address_cast{};
        else
            return v6_;
    }
    constexpr bool is_unspecified() const noexcept { return type_ == ipv4 ? v4_.is_unspecified() : v6_.is_unspecified(); }
    constexpr bool is_loopback() const noexcept { return type_ == ipv4 ? v4_.is_loopback() : v6_.is_loopback(); }
    constexpr bool is_multicast() const noexcept { return type_ == ipv4 ? v4_.is_multicast() : v6_.is_multicast(); }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        return type_ == ipv4 ? v4_.to_string(a) : v6_.to_string(a);
    }

    friend constexpr bool operator==(const address& a, const address& b) noexcept
    {
        if (a.type_ != b.type_)
            return false;
        else
        {
            if (a.type_ == address::ipv4)
                return a.v4_ == b.v4_;
            else
                return a.v6_ == b.v6_;
        }
    }
    friend constexpr bool operator!=(const address& a, const address& b) noexcept { return !(a == b); }
    friend constexpr bool operator<(const address& a, const address& b) noexcept
    {
        if (a.type_ != b.type_)
            return a.type_ < b.type_;
        else
        {
            if (a.type_ == address::ipv4)
                return a.v4_ < b.v4_;
            else
                return a.v6_ > b.v6_;
        }
    }
    friend constexpr bool operator>(const address& a, const address& b) noexcept { return b < a; }
    friend constexpr bool operator<=(const address& a, const address& b) noexcept { return !(b < a); }
    friend constexpr bool operator>=(const address& a, const address& b) noexcept { return !(a < b); }

private:
    enum
    {
        ipv4,
        ipv6
    } type_;
    address_v4 v4_;
    address_v6 v6_;
};

template <class CharT, class Traits>
inline basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const address& a)
{
    return s << a.to_string().c_str();
}

address make_address(const char*, error_code&) noexcept;
inline address make_address(const char* str) { _CHECK_ERROR_CODE_INVOKE_FUNC(make_address(str, ec)); }
inline address make_address(const string& str, error_code& ec) noexcept { return make_address(str.c_str(), ec); }
inline address make_address(const string& str) { return make_address(str.c_str()); }
inline address make_address(string_view str, error_code& ec) noexcept { return make_address(static_cast<string>(str), ec); }
inline address make_address(string_view str) { return make_address(static_cast<string>(str)); }

template <class>
class basic_address_iterator;

template <>
class basic_address_iterator<address_v4>
{
public:
    using value_type = address_v4;
    using difference_type = ptrdiff_t;
    using pointer = const address_v4*;
    using reference = const address_v4&;
    using iterator_category = input_iterator_tag;

    basic_address_iterator(const address_v4& a) noexcept : address_(a) {}

    reference operator*() const noexcept { return address_; }
    pointer operator->() const noexcept { return addressof(address_); }
    basic_address_iterator& operator++() noexcept;
    basic_address_iterator operator++(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        ++(*this);
        return tmp;
    }
    basic_address_iterator& operator--() noexcept;
    basic_address_iterator operator--(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        --(*this);
        return tmp;
    }

    friend bool operator==(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ == b.address_; }
    friend bool operator!=(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ != b.address_; }

private:
    address_v4 address_;
};

using address_v4_iterator = basic_address_iterator<address_v4>;

template <>
class basic_address_iterator<address_v6>
{
public:
    using value_type = address_v6;
    using difference_type = ptrdiff_t;
    using pointer = const address_v6*;
    using reference = const address_v6&;
    using iterator_category = input_iterator_tag;

    basic_address_iterator(const address_v6& a) noexcept : address_(a) {}

    reference operator*() const noexcept { return address_; }
    pointer operator->() const noexcept { return addressof(address_); }
    basic_address_iterator& operator++() noexcept;
    basic_address_iterator operator++(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        ++(*this);
        return tmp;
    }
    basic_address_iterator& operator--() noexcept;
    basic_address_iterator operator--(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        --(*this);
        return tmp;
    }

    friend bool operator==(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ == b.address_; }
    friend bool operator!=(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ != b.address_; }

private:
    address_v6 address_;
};

using address_v6_iterator = basic_address_iterator<address_v6>;

template <class>
class basic_address_range;

template <>
class basic_address_range<address_v4>
{
public:
    using iterator = basic_address_iterator<address_v4>;

    basic_address_range() noexcept : begin_({}), end_({}) {}
    basic_address_range(const address_v4& first, const address_v4& last) noexcept : begin_(first), end_(last) {}

    iterator begin() const noexcept { return begin_; }
    iterator end() const noexcept { return end_; }
    bool empty() const noexcept { return size() == 0; }
    size_t size() const noexcept { return end_->to_uint() - begin_->to_uint(); }
    iterator find(const address_v4& addr) const noexcept { return addr >= *begin_ && addr < *end_ ? iterator{ addr } : end_; }

private:
    iterator begin_;
    iterator end_;
};

using address_v4_range = basic_address_range<address_v4>;

template <>
class basic_address_range<address_v6>
{
public:
    using iterator = basic_address_iterator<address_v6>;

    basic_address_range() noexcept : begin_({}), end_({}) {}
    basic_address_range(const address_v6& first, const address_v6& last) noexcept : begin_(first), end_(last) {}
    basic_address_range(iterator begin, iterator end) : begin_(begin), end_(end) {}

    iterator begin() const noexcept { return begin_; }
    iterator end() const noexcept { return end_; }
    bool empty() const noexcept { return begin_ == end_; }
    iterator find(const address_v6& addr) const noexcept { return addr >= *begin_ && addr < *end_ ? iterator{ addr } : end_; }

private:
    iterator begin_;
    iterator end_;
};

using address_v6_range = basic_address_range<address_v6>;

class network_v4
{
public:
    constexpr network_v4() noexcept : address_(), prefix_length_(0) {}
    constexpr network_v4(const address_v4& addr, int prefix_len) : address_(addr), prefix_length_(prefix_len)
    {
        if (prefix_len < 0 || prefix_len > 32)
            throw out_of_range{ "prefix length too large" };
    }
    constexpr network_v4(const address_v4& addr, const address_v4& mask) : address_(addr), prefix_length_(0)
    {
        address_v4::bytes_type mask_bytes{ mask.to_bytes() };
        bool finished = false;
        for (size_t i{ 0 }; i < mask_bytes.size(); ++i)
        {
            if (finished)
            {
                if (mask_bytes[i])
                {
                    throw invalid_argument{ "non-contiguous netmask" };
                }
                continue;
            }
            else
            {
                switch (mask_bytes[i])
                {
                case 255:
                    prefix_length_ += 8;
                    break;
                case 254: // prefix_length_ += 7
                    ++prefix_length_;
                case 252: // prefix_length_ += 6
                    ++prefix_length_;
                case 248: // prefix_length_ += 5
                    ++prefix_length_;
                case 240: // prefix_length_ += 4
                    ++prefix_length_;
                case 224: // prefix_length_ += 3
                    ++prefix_length_;
                case 192: // prefix_length_ += 2
                    ++prefix_length_;
                case 128: // prefix_length_ += 1
                    ++prefix_length_;
                case 0: // nbits += 0
                    finished = true;
                    break;
                default:
                    throw invalid_argument{ "non-contiguous netmask" };
                }
            }
        }
    }

    constexpr address_v4 address() const noexcept { return address_; }
    constexpr int prefix_length() const noexcept { return prefix_length_; }
    constexpr address_v4 netmask() const noexcept
    {
        uint_least32_t nmbits{ 0xffffffff };
        if (prefix_length_ == 0)
            nmbits = 0;
        else
            nmbits = nmbits << (32 - prefix_length_);
        return address_v4{ nmbits };
    }
    constexpr address_v4 network() const noexcept { return address_v4{ address_.to_uint() & netmask().to_uint() }; }
    constexpr address_v4 broadcast() const noexcept { return address_v4{ network().to_uint() | (netmask().to_uint() ^ 0xFFFFFFFF) }; }
    address_v4_range hosts() const noexcept { return is_host() ? address_v4_range{ address_, address_v4{ address_.to_uint() + 1 } } : address_v4_range{ address_v4{ network().to_uint() + 1 }, broadcast() }; }
    constexpr network_v4 canonical() const noexcept { return network_v4{ network(), netmask() }; }
    constexpr bool is_host() const noexcept { return prefix_length_ == 32; }
    constexpr bool is_subnet_of(const network_v4& other) const noexcept
    {
        if (other.prefix_length_ >= prefix_length_)
            return false;
        const network_v4 me{ address_, other.prefix_length_ };
        return other.canonical() == me.canonical();
    }

    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        basic_ostringstream<char, char_traits<char>, Allocator> s{};
        s << address_.to_string(a) << '/' << prefix_length_;
        return s.str();
    }
    template <class CharT, class Traits>
    friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const network_v4& net)
    {
        return s << net.address_.to_string() << '/' << net.prefix_length_;
    }

    friend constexpr bool operator==(const network_v4& a, const network_v4& b) noexcept { return a.address_ == b.address_ && a.prefix_length_ == b.prefix_length_; }
    friend constexpr bool operator!=(const network_v4& a, const network_v4& b) noexcept { return !(a == b); }

private:
    address_v4 address_;
    int prefix_length_;
};

inline network_v4 make_network_v4(const address_v4& addr, int prefix_len) { return network_v4{ addr, prefix_len }; }
inline network_v4 make_network_v4(const address_v4& addr, const address_v4& mask) { return network_v4{ addr, mask }; }
network_v4 make_network_v4(const string&, error_code&) noexcept;
inline network_v4 make_network_v4(const string& str) { _CHECK_ERROR_CODE_INVOKE_FUNC(make_network_v4(str, ec)); }
inline network_v4 make_network_v4(const char* str, error_code& ec) noexcept { return make_network_v4(string{ str }, ec); }
inline network_v4 make_network_v4(const char* str) { return make_network_v4(string{ str }); }
inline network_v4 make_network_v4(string_view str, error_code& ec) noexcept { return make_network_v4(static_cast<string>(str), ec); }
inline network_v4 make_network_v4(string_view str) { return make_network_v4(static_cast<string>(str)); }

class network_v6
{
public:
    constexpr network_v6() noexcept : address_(), prefix_length_(0) {}
    constexpr network_v6(const address_v6& addr, int prefix_len) : address_(addr), prefix_length_(prefix_len)
    {
        if (prefix_len < 0 || prefix_len > 128)
            throw out_of_range{ "prefix length too large" };
    }

    constexpr address_v6 address() const noexcept { return address_; }
    constexpr int prefix_length() const noexcept { return prefix_length_; }
    constexpr address_v6 network() const noexcept
    {
        address_v6::bytes_type bytes{ address_.to_bytes() };
        for (size_t i{ 0 }; i < 16; ++i)
        {
            if (prefix_length_ <= i * 8)
                bytes[i] = 0;
            else if (prefix_length_ < (i + 1) * 8)
                bytes[i] &= 0xFF00 >> (prefix_length_ % 8);
        }
        return address_v6{ bytes, address_.scope_id() };
    }
    address_v6_range hosts() const noexcept
    {
        address_v6::bytes_type begin_bytes{ address_.to_bytes() };
        address_v6::bytes_type end_bytes{ address_.to_bytes() };
        for (size_t i{ 0 }; i < 16; ++i)
        {
            if (prefix_length_ <= i * 8)
            {
                begin_bytes[i] = 0;
                end_bytes[i] = 0xFF;
            }
            else if (prefix_length_ < (i + 1) * 8)
            {
                begin_bytes[i] &= 0xFF00 >> (prefix_length_ % 8);
                end_bytes[i] |= 0xFF >> (prefix_length_ % 8);
            }
        }
        return address_v6_range{ address_v6_iterator{ address_v6{ begin_bytes, address_.scope_id() } }, ++address_v6_iterator{ address_v6{ end_bytes, address_.scope_id() } } };
    }
    constexpr network_v6 canonical() const noexcept { return network_v6{ network(), prefix_length() }; }
    constexpr bool is_host() const noexcept { return prefix_length_ == 128; }
    constexpr bool is_subnet_of(const network_v6& other) const noexcept
    {
        if (other.prefix_length_ >= prefix_length_)
            return false;
        const network_v6 me{ address_, other.prefix_length_ };
        return other.canonical() == me.canonical();
    }

    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        basic_ostringstream<char, char_traits<char>, Allocator> s{};
        s << address_.to_string(a) << '/' << prefix_length_;
        return s.str();
    }
    template <class CharT, class Traits>
    friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const network_v6& net)
    {
        return s << net.address_.to_string() << '/' << net.prefix_length_;
    }

    friend constexpr bool operator==(const network_v6& a, const network_v6& b) noexcept { return a.address_ == b.address_ && a.prefix_length_ == b.prefix_length_; }
    friend constexpr bool operator!=(const network_v6& a, const network_v6& b) noexcept { return !(a == b); }

private:
    address_v6 address_;
    int prefix_length_;
};

inline network_v6 make_network_v6(const address_v6& addr, int prefix_len) { return network_v6{ addr, prefix_len }; }
network_v6 make_network_v6(const string&, error_code&) noexcept;
inline network_v6 make_network_v6(const string& str) { _CHECK_ERROR_CODE_INVOKE_FUNC(make_network_v6(str, ec)); }
inline network_v6 make_network_v6(const char* str, error_code& ec) noexcept { return make_network_v6(string{ str }, ec); }
inline network_v6 make_network_v6(const char* str) { return make_network_v6(string{ str }); }
inline network_v6 make_network_v6(string_view str, error_code& ec) noexcept { return make_network_v6(static_cast<string>(str), ec); }
inline network_v6 make_network_v6(string_view str) { return make_network_v6(static_cast<string>(str)); }

template <class InternetProtocol>
class basic_endpoint
{
public:
    using protocol_type = InternetProtocol;

    constexpr basic_endpoint() noexcept : data_() { data_.v4.sin_family = protocal_type::v4().family(); }
    constexpr basic_endpoint(const protocol_type& proto, port_type port_num) noexcept : data_()
    {
        data_.v4.sin_family = proto.family();
        data_.v4.sin_port = ::htons(port_num);
    }
    constexpr basic_endpoint(const address& addr, port_type port_num) noexcept : data_()
    {
        if (addr.is_v4())
        {
            data_.v4.sin_family = protocol_type::v4().family();
            data_.v4.sin_port = ::htons(port_num);
            data_.v4.sin_addr.s_addr = ::htonl(addr.to_v4().to_uint());
        }
        else
        {
            data_.v6 = {};
            data_.v6.sin6_family = protocol_type::v6().family();
            data_.v6.sin6_family = ::htons(port_num);
            auto v6a{ addr.to_v6() };
            auto bytes{ v6a.to_bytes() };
            memcpy(data_.v6.sin6_addr.s6_addr, bytes.data(), 16);
            data_.v6.sin6_scope_id = v6a.scope_id();
        }
    }
    constexpr basic_endpoint(const ::sockaddr_in& addr) noexcept : data_() { data_.v4 = addr; }
    constexpr basic_endpoint(const ::sockaddr_in6& addr) noexcept : data_() { data_.v6 = addr; }

    constexpr protocol_type protocol() const noexcept { return data_.v4.sin_family == AF_INET ? protocol_type::v4() : protocol_type::v6(); }
    constexpr address address() const noexcept
    {
        if (data_.v4.sin_family == AF_INET)
        {
            address_v4 addr{ data_.v4.sin_addr };
            return addr;
        }
        else
        {
            address_v6 addr{};
            memcpy(addr._Addr().s6_addr, data_.v6.sin6_addr.s6_addr, 16);
            addr.scope_id = data_.v6.sin6_scope_id;
            return addr;
        }
    }
    void address(const address& addr) noexcept
    {
        if (addr.is_v4())
        {
            data_.v4.sin_family = protocol_type::v4().family();
            data_.v4.sin_addr = addr.to_v4()._Addr();
        }
        else
        {
            data_.v6 = {};
            data_.v6.sin6_family = protocol_type::v6().family();
            auto v6a{ addr.to_v6() };
            memcpy(data_.v6.sin6_addr.s6_addr, v6a._Addr().s6_addr, 16);
            data_.v6.sin6_scope_id = v6a.scope_id();
        }
    }
    constexpr port_type port() const noexcept { return ::ntohs(data_.v4.sin_port); }
    void port(port_type port_num) noexcept { data_.v4.sin_port = ::htons(port_num); }

    void* data() noexcept { return &data_; }
    const void* data() const noexcept { return &data_; }
    constexpr size_t size() const noexcept { return data_.v4.sin_family == AF_INET ? sizeof(::sockaddr_in) : sizeof(::sockaddr_in6); }
    void resize(size_t s)
    {
        if ((data_.v4.sin_family == AF_INET && s != sizeof(::sockaddr_in)) || (data_.v4.sin_family == AF_INET6 && s != sizeof(::sockaddr_in6)))
            throw length_error{ "invalid end_point size" };
    }
    constexpr size_t capacity() const noexcept { return sizeof(data_); }

private:
    union {
        ::sockaddr_in v4;
        ::sockaddr_in6 v6;
    } data_;
};

template <class InternetProtocol>
constexpr bool operator==(const basic_endpoint<InternetProtocol>& a, const basic_endpoint<InternetProtocol>& b)
{
    return a.address() == b.address() && a.port() == b.port();
}
template <class InternetProtocol>
constexpr bool operator!=(const basic_endpoint<InternetProtocol>& a, const basic_endpoint<InternetProtocol>& b)
{
    return !(a == b);
}
template <class InternetProtocol>
constexpr bool operator<(const basic_endpoint<InternetProtocol>& a, const basic_endpoint<InternetProtocol>& b)
{
    return a.address() < b.address() && a.port() < b.port();
}
template <class InternetProtocol>
constexpr bool operator>(const basic_endpoint<InternetProtocol>& a, const basic_endpoint<InternetProtocol>& b)
{
    return b < a;
}
template <class InternetProtocol>
constexpr bool operator<=(const basic_endpoint<InternetProtocol>& a, const basic_endpoint<InternetProtocol>& b)
{
    return !(b < a);
}
template <class InternetProtocol>
constexpr bool operator>=(const basic_endpoint<InternetProtocol>& a, const basic_endpoint<InternetProtocol>& b)
{
    return !(a < b);
}

template <class CharT, class Traits, class InternetProtocol>
inline basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& os, const basic_endpoint<InternetProtocol>& ep)
{
    basic_ostringstream<CharT, Traits> ss;
    if (ep.protocol() == basic_endpoint<InternetProtocol>::protocol_type::v6())
        ss << "[" << ep.address() << "]";
    else
        ss << ep.address();
    ss << ":" << ep.port();
    os << ss.str();
    return os;
}

template <class InternetProtocol>
class basic_resolver_entry
{
public:
    using protocol_type = InternetProtocol;
    using endpoint_type = typename InternetProtocol::endpoint;

    basic_resolver_entry() {}
    basic_resolver_entry(const endpoint_type& ep, string_view h, string_view s) : ep_(ep), host_(h), svc_(s) {}

    endpoint_type endpoint() const { return ep_; }
    operator endpoint_type() const { return ep_; }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> host_name(const Allocator& a = {}) const
    {
        return basic_string{ host_, a };
    }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> service_name(const Allocator& a = {}) const
    {
        return basic_string{ svc_, a };
    }

    template <class InternetProtocol>
    friend bool operator==(const basic_resolver_entry<InternetProtocol>& a, const basic_resolver_entry<InternetProtocol>& b)
    {
        return a.ep_ == b.ep_ && a.host_ == b.host_ && a.svc_ == b.svc_;
    }
    template <class InternetProtocol>
    friend bool operator!=(const basic_resolver_entry<InternetProtocol>& a, const basic_resolver_entry<InternetProtocol>& b)
    {
        return !(a == b);
    }

private:
    endpoint_type ep_;
    string host_;
    string svc_;
};

template <class InternetProtocol>
class basic_resolver_results
{
public:
    using protocol_type = InternetProtocol;
    using endpoint_type = typename protocol_type::endpoint;
    using value_type = basic_resolver_entry<protocol_type>;
    using const_reference = const value_type&;
    using reference = value_type&;
    using const_iterator = typename vector<value_type>::const_iterator;
    using iterator = const_iterator;
    using difference_type = ptrdiff_t;
    using size_type = size_t;

    basic_resolver_results() = default;
    basic_resolver_results(const basic_resolver_results&) = default;
    basic_resolver_results(basic_resolver_results&&) noexcept = default;
    basic_resolver_results& operator=(const basic_resolver_results&) = default;
    basic_resolver_results& operator=(basic_resolver_results&&) = default;
    ~basic_resolver_results() = default;

    size_type size() const noexcept { return results_.size(); }
    size_type max_size() const noexcept { return results_.max_size(); }
    bool empty() const noexcept { return results_.empty(); }

    const_iterator begin() const { return results_.begin(); }
    const_iterator end() const { return results_.end(); }
    const_iterator cbegin() const { return results_.cbegin(); }
    const_iterator cend() const { return results_.cend(); }

    void swap(basic_resolver_results& that) noexcept { results_.swap(that.results_); }

private:
    friend class basic_resolver<InternetProtocol>;

    vector<value_type> results_;
};

template <class InternetProtocol>
inline bool operator==(const basic_resolver_results<InternetProtocol>& a, const basic_resolver_results<InternetProtocol>& b)
{
    return a.size() == b.size() && equal(a.begin(), a.end(), b.begin());
}
template <class InternetProtocol>
inline bool operator!=(const basic_resolver_results<InternetProtocol>& a, const basic_resolver_results<InternetProtocol>& b)
{
    return !(a == b);
}

class resolver_base
{
public:
    enum class flags
    {
        passive = AI_PASSIVE,
        canonical_name = AI_CANONNAME,
        numeric_host = AI_NUMERICHOST,
        numeric_service = AI_NUMERICSERV,
        v4_mapped = AI_V4MAPPED,
        all_matching = AI_ALL,
        address_configured = AI_ADDRCONFIG
    };
    static constexpr flags passive{ flags::passive };
    static constexpr flags canonical_name{ flags::canonical_name };
    static constexpr flags numeric_host{ flags::numeric_host };
    static constexpr flags numeric_service{ flags::numeric_service };
    static constexpr flags v4_mapped{ flags::v4_mapped };
    static constexpr flags all_matching{ flags::all_matching };
    static constexpr flags address_configured{ flags::address_configured };

protected:
    resolver_base() = default;
    ~resolver_base() = default;
};

template <class InternetProtocol>
class basic_resolver : public resolver_base
{
public:
    using executor_type = io_context::executor_type;
    using protocol_type = InternetProtocol;
    using endpoint_type = typename InternetProtocol::endpoint;
    using results_type = basic_resolver_results<InternetProtocol>;

    explicit basic_resolver(io_context& ctx) : ctx_(&ctx) {}
    basic_resolver(const basic_resolver&) = delete;
    basic_resolver(basic_resolver&& rhs) noexcept : ctx_(move(rhs.ctx_)) {}

    ~basic_resolver() { cancel(); }

    basic_resolver& operator=(const basic_resolver&) = delete;
    basic_resolver& operator=(basic_resolver&& rhs)
    {
        cancel();
        ctx_ = move(rhs.ctx_);
        return *this;
    }

    executor_type get_executor() noexcept { return ctx_->get_executor(); }

    void cancel();

    results_type resolve(string_view host_name, string_view service_name, flags f, error_code& ec)
    {
        ::addrinfo hints;
        hints.ai_flags = static_cast<int>(f);
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = endpoint_type{}.protocol().type();
        hints.ai_protocol = endpoint_type{}.protocol().protocol();
        hints.ai_addr = nullptr;
        hints.ai_addrlen = 0;
        hints.ai_canonname = nullptr;
        hints.ai_next = nullptr;
        ::addrinfo* result = nullptr;
        int r{ ::getaddrinfo(host_name.empty() ? nullptr : static_cast<string>(host_name).c_str(), service_name.empty() ? nullptr : static_cast<string>(service_name).c_str(), &hints, &result) };
        if (r != 0)
            ec = make_error_code(static_cast<resolver_errc>(r));
        results_type results{};
        for (::addrinfo* ptr{ result }; ptr; ptr = ptr->ai_next)
        {
            if (ptr->ai_family == AF_INET)
                results.results_.emplace_back(*(::sockaddr_in*)ptr->ai_addr, ptr->ai_canonname, service_name);
            else
                results.results_.emplace_back(*(::sockaddr_in6*)ptr->ai_addr, ptr->ai_canonname, service_name);
        }
        ::freeaddrinfo(result);
        return results;
    }
    results_type resolve(string_view host_name, string_view service_name, flags f) { _CHECK_ERROR_CODE_INVOKE_FUNC(resolve(host_name, service_name, f, ec)); }
    results_type resolve(string_view host_name, string_view service_name, error_code& ec) { return resolve(host_name, service_name, flags{}, ec); }
    results_type resolve(string_view host_name, string_view service_name) { return resolve(host_name, service_name, flags{}); }

    template <class CompletionToken>
    auto async_resolve(string_view host_name, string_view service_name, CompletionToken&& token);
    template <class CompletionToken>
    auto async_resolve(string_view host_name, string_view service_name, flags f, CompletionToken&& token);

    results_type resolve(const protocol_type& protocol, string_view host_name, string_view service_name, flags f, error_code& ec)
    {
        ::addrinfo hints;
        hints.ai_flags = static_cast<int>(f);
        hints.ai_family = protocol.family();
        hints.ai_socktype = protocol.type();
        hints.ai_protocol = protocol.protocol();
        hints.ai_addr = nullptr;
        hints.ai_addrlen = 0;
        hints.ai_canonname = nullptr;
        hints.ai_next = nullptr;
        ::addrinfo* result = nullptr;
        int r{ ::getaddrinfo(host_name.empty() ? nullptr : static_cast<string>(host_name).c_str(), service_name.empty() ? nullptr : static_cast<string>(service_name).c_str(), &hints, &result) };
        if (r != 0)
        {
            ec = make_error_code(static_cast<resolver_errc>(r));
            return {};
        }
        results_type results{};
        for (::addrinfo* ptr{ result }; ptr; ptr = ptr->ai_next)
        {
            if (ptr->ai_family == AF_INET)
                results.results_.emplace_back(*(::sockaddr_in*)ptr->ai_addr, ptr->ai_canonname, service_name);
            else
                results.results_.emplace_back(*(::sockaddr_in6*)ptr->ai_addr, ptr->ai_canonname, service_name);
        }
        ::freeaddrinfo(result);
        return results;
    }
    results_type resolve(const protocol_type& protocol, string_view host_name, string_view service_name, flags f) { _CHECK_ERROR_CODE_INVOKE_FUNC(resolve(protocol, host_name, service_name, f, ec)); }
    results_type resolve(const protocol_type& protocol, string_view host_name, string_view service_name, error_code& ec) { return resolve(protocol, host_name, service_name, flags{}, ec); }
    results_type resolve(const protocol_type& protocol, string_view host_name, string_view service_name) { return resolve(protocol, host_name, service_name, flags{}); }

    template <class CompletionToken>
    auto async_resolve(const protocol_type& protocol, string_view host_name, string_view service_name, CompletionToken&& token);
    template <class CompletionToken>
    auto async_resolve(const protocol_type& protocol, string_view host_name, string_view service_name, flags f, CompletionToken&& token);

    results_type resolve(const endpoint_type& e, error_code& ec)
    {
        char host_name[256];
        char service_name[256];
        int flags{ 0 };
        if (e.protocol().type() == SOCK_DGRAM)
            flags |= NI_DGRAM;
        int result{ ::getnameinfo((const sockaddr*)e.data(), e.size(), host_name, 256, service_name, 256, flags) };
        if (result != 0)
        {
            flags |= NI_NUMERICSERV;
            result = ::getnameinfo((const sockaddr*)e.data(), e.size(), host_name, 256, service_name, 256, flags);
        }
        if (result != 0)
        {
            ec = make_error_code(static_cast<resolver_errc>(r));
            return {};
        }
        results_type results{};
        if (e.protocol().family() == AF_INET)
            results.results_.emplace_back(*(sockaddr_in*)e.data(), host_name, service_name);
        else
            results.results_.emplace_back(*(sockaddr_in6*)e.data(), host_name, service_name);
        return results;
    }
    results_type resolve(const endpoint_type& e) { _CHECK_ERROR_CODE_INVOKE_FUNC(resolve(e, ec)); }

    template <class CompletionToken>
    auto async_resolve(const endpoint_type& e, CompletionToken&& token);

private:
    io_context* ctx_;
};

template <class Allocator>
inline basic_string<char, char_traits<char>, Allocator> host_name(const Allocator& a, error_code& ec)
{
    char buffer[257];
    if (::gethostname(buffer, 256) != 0)
        ec = error_code{ ::WSAGetLastError(), generic_category() };
    buffer[256] = '\0';
    return basic_string{ buffer, a };
}
template <class Allocator>
inline basic_string<char, char_traits<char>, Allocator> host_name(const Allocator& a)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(host_name(a, ec));
}
inline string host_name(error_code& ec) { return host_name<allocator<char>>({}, ec); }
inline string host_name() { return host_name<allocator<char>>({}); }

class tcp
{
public:
    using endpoint = basic_endpoint<tcp>;
    using resolver = basic_resolver<tcp>;
    using socket = basic_stream_socket<tcp>;
    using acceptor = basic_socket_acceptor<tcp>;
    using iostream = basic_socket_iostream<tcp>;

    class no_delay : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return IPPROTO_TCP;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return TCP_NODELAY;
        }
    };

    static constexpr tcp v4() noexcept { return tcp{ AF_INET }; }
    static constexpr tcp v6() noexcept { return tcp{ AF_INET6 }; }

    constexpr int family() const noexcept { return family_; }
    constexpr int type() const noexcept { return SOCK_STREAM; }
    constexpr int protocol() const noexcept { return IPPROTO_TCP; }

private:
    constexpr explicit tcp(int family) : family_(family) {}

    int family_;
};

inline bool operator==(const tcp& a, const tcp& b) { return a.family() == b.family(); }
inline bool operator!=(const tcp& a, const tcp& b) { return !(a == b); }

class udp
{
public:
    using endpoint = basic_endpoint<udp>;
    using resolver = basic_resolver<udp>;
    using socket = basic_datagram_socket<udp>;

    static constexpr udp v4() noexcept { return udp{ AF_INET }; }
    static constexpr udp v6() noexcept { return udp{ AF_INET6 }; }

    constexpr int family() const noexcept { return family_; }
    constexpr int type() const noexcept { return SOCK_DGRAM; }
    constexpr int protocol() const noexcept { return IPPROTO_UDP; }

private:
    constexpr explicit udp(int family) : family_(family) {}

    int family_;
};

inline bool operator==(const udp& a, const udp& b) { return a.family() == b.family(); }
inline bool operator!=(const udp& a, const udp& b) { return !(a == b); }

class v6_only : public _Option_base<int>
{
public:
    using _Option_base<int>::_Option_base;

    template <class Protocol>
    int level(const Protocol&) const noexcept
    {
        return IPPROTO_IPV6;
    }
    template <class Protocol>
    int name(const Protocol&) const noexcept
    {
        return IPV6_V6ONLY;
    }
};

namespace unicast
{
class hops : public _Option_base<int>
{
public:
    using _Option_base<int>::_Option_base;

    template <class Protocol>
    int level(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IPPROTO_IP : IPPROTO_IPV6;
    }
    template <class Protocol>
    int name(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IP_TTL : IPV6_UNICAST_HOPS;
    }
};
} // namespace unicast

namespace multicast
{
union _Group_t {
    ::ip_mreq v4_value_;
    ::ipv6_mreq v6_value_;
};

constexpr _Group_t _Make_Group_t(::ip_mreq val) { return _Group_t{ val }; }
constexpr _Group_t _Make_Group_t(::ipv6_mreq val)
{
    _Group_t r{};
    r.v6_value_ = val;
    return r;
}

class join_group : public _Option_base<_Group_t>
{
public:
    explicit join_group(const address_v4& a, const address_v4& i = address_v4::any()) : _Option_base<_Group_t>(_Make_Group_t(::ip_mreq{ a._Addr(), i._Addr() })) {}
    explicit join_group(const address_v6& a, unsigned long i = 0) : _Option_base<_Group_t>(_Make_Group_t(::ipv6_mreq{ a._Addr(), i })) {}
    explicit join_group(const address& a)
        : _Option_base<_Group_t>(a.is_v4() ? _Make_Group_t(::ip_mreq{ a.to_v4()._Addr(), address_v4::any()._Addr() }) : _Make_Group_t(::ipv6_mreq{ a.to_v6()._Addr(), 0 })) {}

    template <class Protocol>
    int level(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IPPROTO_IP : IPPROTO_IPV6;
    }
    template <class Protocol>
    int name(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IP_ADD_MEMBERSHIP : IPV6_JOIN_GROUP;
    }
};
class leave_group : public _Option_base<_Group_t>
{
public:
    explicit leave_group(const address_v4& a, const address_v4& i = address_v4::any()) : _Option_base<_Group_t>(_Make_Group_t(::ip_mreq{ a._Addr(), i._Addr() })) {}
    explicit leave_group(const address_v6& a, unsigned long i = 0) : _Option_base<_Group_t>(_Make_Group_t(::ipv6_mreq{ a._Addr(), i })) {}
    explicit leave_group(const address& a)
        : _Option_base<_Group_t>(a.is_v4() ? _Make_Group_t(::ip_mreq{ a.to_v4()._Addr(), address_v4::any()._Addr() }) : _Make_Group_t(::ipv6_mreq{ a.to_v6()._Addr(), 0 })) {}

    template <class Protocol>
    int level(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IPPROTO_IP : IPPROTO_IPV6;
    }
    template <class Protocol>
    int name(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IP_DROP_MEMBERSHIP : IPV6_LEAVE_GROUP;
    }
};
class hops : public _Option_base<int>
{
public:
    using _Option_base<int>::_Option_base;

    template <class Protocol>
    int level(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IPPROTO_IP : IPPROTO_IPV6;
    }
    template <class Protocol>
    int name(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IP_MULTICAST_TTL : IPV6_MULTICAST_HOPS;
    }
};
class enable_loopback : public _Option_base<int>
{
public:
    using _Option_base<int>::_Option_base;

    template <class Protocol>
    int level(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IPPROTO_IP : IPPROTO_IPV6;
    }
    template <class Protocol>
    int name(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IP_MULTICAST_LOOP : IPV6_MULTICAST_LOOP;
    }
};

union _Outbound_interface_t {
    ::in_addr v4_value_;
    unsigned int v6_value_;
};

constexpr _Outbound_interface_t _Make_Outbound_interface_t(::in_addr val) { return _Outbound_interface_t{ val }; }
constexpr _Outbound_interface_t _Make_Outbound_interface_t(unsigned int val)
{
    _Outbound_interface_t r{};
    r.v6_value_ = val;
    return r;
}

class outbound_interface : public _Option_base<_Outbound_interface_t>
{
public:
    explicit outbound_interface(const address_v4& network_interface) noexcept : _Option_base<_Outbound_interface_t>(_Make_Outbound_interface_t(network_interface._Addr())) {}
    explicit outbound_interface(unsigned int network_interface) noexcept : _Option_base<_Outbound_interface_t>(_Make_Outbound_interface_t(network_interface)) {}

    template <class Protocol>
    int level(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IPPROTO_IP : IPPROTO_IPV6;
    }
    template <class Protocol>
    int name(const Protocol& p) const noexcept
    {
        return p.family() == AF_INET ? IP_MULTICAST_IF : IPV6_MULTICAST_IF;
    }
};
} // namespace multicast
} // namespace ip
} // namespace v1
} // namespace experimental::net
template <>
struct is_error_condition_enum<experimental::net::v1::ip::resolver_errc> : public true_type
{
};

template <>
struct hash<experimental::net::v1::ip::address_v4>
{
    size_t operator()(const experimental::net::v1::ip::address_v4& a) const
    {
        auto bytes{ a.to_bytes() };
        return _Hash_array_representation(bytes.data(), bytes.size());
    }
};
template <>
struct hash<experimental::net::v1::ip::address_v6>
{
    size_t operator()(const experimental::net::v1::ip::address_v6& a) const
    {
        auto bytes{ a.to_bytes() };
        return _Hash_array_representation(bytes.data(), bytes.size());
    }
};
template <>
struct hash<experimental::net::v1::ip::address>
{
    size_t operator()(const experimental::net::v1::ip::address& a) const
    {
        if (a.is_v4())
            return hash<experimental::net::v1::ip::address_v4>{}(a.to_v4());
        else
            return hash<experimental::net::v1::ip::address_v6>{}(a.to_v6());
    }
};
} // namespace std

#endif
