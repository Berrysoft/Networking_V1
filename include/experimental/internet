#ifndef NET_INTERNET
#define NET_INTERNET

#include <arpa/inet.h>
#include <array>
#include <cstring>
#include <experimental/netfwd>
#include <functional>
#include <netinet/in.h>
#include <sstream>
#include <string>
#include <string_view>
#include <system_error>
#include <type_traits>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
namespace ip
{
enum class resolver_errc
{
    host_not_found = -2, // EAI_NONAME
    try_again = -3, // EAI_AGAIN
    service_not_found = -8 // EAI_SERVICE
};

struct _Resolver_category : error_category
{
    const char* name() const noexcept override { return "resolver"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(resolver_errc::host_not_found):
            return "Host not found";
        case static_cast<int>(resolver_errc::try_again):
            return "Try again later";
        case static_cast<int>(resolver_errc::service_not_found):
            return "Service not found";
        default:
            return "resolver error";
        }
    }
};

inline const error_category& resolver_category() noexcept
{
    static _Resolver_category instance{};
    return instance;
}

inline error_code make_error_code(resolver_errc e) noexcept { return error_code{ static_cast<int>(e), resolver_category() }; }
inline error_condition make_error_condition(resolver_errc e) noexcept { return error_condition{ static_cast<int>(e), resolver_category() }; }

using port_type = uint_least16_t;
using scope_id_type = uint_least32_t;

struct v4_mapped_t
{
};
constexpr v4_mapped_t v4_mapped{};

struct bad_address_cast : bad_cast
{
    bad_address_cast() noexcept : bad_cast() {}
};

class address_v4
{
public:
    using uint_type = uint_least32_t;
    struct bytes_type : array<unsigned char, 4>
    {
        template <class... T>
        explicit constexpr bytes_type(T... t) : array<unsigned char, 4>{ static_cast<unsigned char>(t)... }
        {
        }
    };

    constexpr address_v4() noexcept : addr_() { addr_.s_addr = 0; }
    constexpr address_v4(const address_v4& a) noexcept : addr_(a.addr_) {}
    constexpr address_v4(const bytes_type& bytes) : addr_() { copy(bytes.begin(), bytes.end(), (unsigned char*)&addr_.s_addr); }
    explicit constexpr address_v4(uint_type val) : addr_() { addr_.s_addr = ::htonl(val); }

    address_v4& operator=(const address_v4& a) noexcept
    {
        addr_ = a.addr_;
        return *this;
    }

    constexpr bytes_type to_bytes() const noexcept
    {
        bytes_type bytes{};
        copy((unsigned char*)&addr_.s_addr, (unsigned char*)&addr_.s_addr + sizeof(uint_type), bytes.begin());
        return bytes;
    }
    constexpr uint_type to_uint() const noexcept { return ::ntohl(addr_.s_addr); }
    constexpr bool is_unspecified() const noexcept { return to_uint() == 0; }
    constexpr bool is_loopback() const noexcept { return (to_uint() & 0xFF000000) == 0x7F000000; }
    constexpr bool is_multicast() const noexcept { return (to_uint() & 0xF0000000) == 0xE0000000; }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        char addr_str[256];
        const char* r{ ::inet_ntop(AF_INET, &addr_, addr_str, 256) };
        if (r)
            return basic_string{ r, a };
        else
            return basic_string<char>{ a };
    }

    static constexpr address_v4 any() noexcept { return address_v4{}; }
    static constexpr address_v4 loopback() noexcept { return address_v4{ 0x7F000001 }; }
    static constexpr address_v4 broadcast() noexcept { return address_v4{ 0xFFFFFFFF }; }

    friend constexpr bool operator==(const address_v4& a, const address_v4& b) noexcept { return a.addr_.s_addr == b.addr_.s_addr; }
    friend constexpr bool operator!=(const address_v4& a, const address_v4& b) noexcept { return !(a == b); }
    friend constexpr bool operator<(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() < b.to_uint(); }
    friend constexpr bool operator>(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() > b.to_uint(); }
    friend constexpr bool operator<=(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() <= b.to_uint(); }
    friend constexpr bool operator>=(const address_v4& a, const address_v4& b) noexcept { return a.to_uint() >= b.to_uint(); }

private:
    ::in_addr addr_;
};

template <class CharT, class Traits>
inline basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const address_v4& a)
{
    return s << a.to_string().c_str();
}

constexpr address_v4 make_address_v4(const address_v4::bytes_type& bytes) { return address_v4{ bytes }; }
constexpr address_v4 make_address_v4(address_v4::uint_type val) { return address_v4{ val }; }
constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6& a)
{
    if (!a.is_v4_mapped())
        throw bad_address_cast{};
    address_v6::bytes_type v6b{ a.to_bytes() };
    address_v4::bytes_type v4b{ v6b[12], v6b[13], v6b[14], v6b[15] };
    return address_v4{ v4b };
}
address_v4 make_address_v4(const char*, error_code&) noexcept;
inline address_v4 make_address_v4(const char* str)
{
    error_code ec{};
    auto r{ make_address_v4(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline address_v4 make_address_v4(const string& str, error_code& ec) noexcept { return make_address_v4(str.c_str(), ec); }
inline address_v4 make_address_v4(const string& str)
{
    error_code ec{};
    auto r{ make_address_v4(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline address_v4 make_address_v4(string_view str, error_code& ec) noexcept { return make_address_v4(static_cast<string>(str), ec); }
inline address_v4 make_address_v4(string_view str)
{
    error_code ec{};
    auto r{ make_address_v4(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

class address_v6
{
public:
    struct bytes_type : array<unsigned char, 16>
    {
        template <class... T>
        explicit constexpr bytes_type(T... t) : array<unsigned char, 16>{ static_cast<unsigned char>(t)... }
        {
        }
    };
    constexpr address_v6() noexcept : addr_(), scope_id_(0) {}
    constexpr address_v6(const address_v6& a) noexcept : addr_(a.addr_), scope_id_(a.scope_id_) {}
    constexpr address_v6(const bytes_type& bytes, scope_id_type scope = 0) : addr_(), scope_id_(scope) { copy(bytes.begin(), bytes.end(), (unsigned char*)addr_.s6_addr); }

    address_v6& operator=(const address_v6& a) noexcept
    {
        addr_ = a.addr_;
        scope_id_ = a.scope_id_;
        return *this;
    }

    void scope_id(scope_id_type id) noexcept { scope_id_ = id; }
    constexpr scope_id_type scope_id() const noexcept { return scope_id_; }
    constexpr bool is_unspecified() const noexcept
    {
        return (addr_.s6_addr[0] == 0) &&
               (addr_.s6_addr[1] == 0) &&
               (addr_.s6_addr[2] == 0) &&
               (addr_.s6_addr[3] == 0) &&
               (addr_.s6_addr[4] == 0) &&
               (addr_.s6_addr[5] == 0) &&
               (addr_.s6_addr[6] == 0) &&
               (addr_.s6_addr[7] == 0) &&
               (addr_.s6_addr[8] == 0) &&
               (addr_.s6_addr[9] == 0) &&
               (addr_.s6_addr[10] == 0) &&
               (addr_.s6_addr[11] == 0) &&
               (addr_.s6_addr[12] == 0) &&
               (addr_.s6_addr[13] == 0) &&
               (addr_.s6_addr[14] == 0) &&
               (addr_.s6_addr[15] == 0);
    }
    constexpr bool is_loopback() const noexcept
    {
        return (addr_.s6_addr[0] == 0) &&
               (addr_.s6_addr[1] == 0) &&
               (addr_.s6_addr[2] == 0) &&
               (addr_.s6_addr[3] == 0) &&
               (addr_.s6_addr[4] == 0) &&
               (addr_.s6_addr[5] == 0) &&
               (addr_.s6_addr[6] == 0) &&
               (addr_.s6_addr[7] == 0) &&
               (addr_.s6_addr[8] == 0) &&
               (addr_.s6_addr[9] == 0) &&
               (addr_.s6_addr[10] == 0) &&
               (addr_.s6_addr[11] == 0) &&
               (addr_.s6_addr[12] == 0) &&
               (addr_.s6_addr[13] == 0) &&
               (addr_.s6_addr[14] == 0) &&
               (addr_.s6_addr[15] == 1);
    }
    constexpr bool is_multicast() const noexcept { return (addr_.s6_addr[0] == 0xff); }
    constexpr bool is_link_local() const noexcept { return (addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0x80); }
    constexpr bool is_site_local() const noexcept { return (addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0xc0); }
    constexpr bool is_v4_mapped() const noexcept
    {
        return (addr_.s6_addr[0] == 0) &&
               (addr_.s6_addr[1] == 0) &&
               (addr_.s6_addr[2] == 0) &&
               (addr_.s6_addr[3] == 0) &&
               (addr_.s6_addr[4] == 0) &&
               (addr_.s6_addr[5] == 0) &&
               (addr_.s6_addr[6] == 0) &&
               (addr_.s6_addr[7] == 0) &&
               (addr_.s6_addr[8] == 0) &&
               (addr_.s6_addr[9] == 0) &&
               (addr_.s6_addr[10] == 0xff) &&
               (addr_.s6_addr[11] == 0xff);
    }
    constexpr bool is_multicast_node_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x01); }
    constexpr bool is_multicast_link_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x02); }
    constexpr bool is_multicast_site_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x05); }
    constexpr bool is_multicast_org_local() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x08); }
    constexpr bool is_multicast_global() const noexcept { return (addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x0e); }
    constexpr bytes_type to_bytes() const noexcept
    {
        bytes_type bytes;
        copy((unsigned char*)addr_.s6_addr, (unsigned char*)addr_.s6_addr + 16, bytes.begin());
        return bytes;
    }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        char addr_str[256];
        const char* r{ ::inet_ntop(AF_INET6, &addr_, addr_str, 256) };
        if (r)
            return basic_string{ r, a };
        else
            return basic_string<char>{ a };
    }

    static constexpr address_v6 any() noexcept { return address_v6{}; }
    static constexpr address_v6 loopback() noexcept
    {
        address_v6 tmp;
        tmp.addr_.s6_addr[15] = 1;
        return tmp;
    }

    friend constexpr bool operator==(const address_v6& a, const address_v6& b) noexcept
    {
        return memcmp(&a.addr_, &b.addr_, sizeof(::in6_addr)) == 0 && a.scope_id_ == b.scope_id_;
    }
    friend constexpr bool operator!=(const address_v6& a, const address_v6& b) noexcept { return !(a == b); }
    friend constexpr bool operator<(const address_v6& a, const address_v6& b) noexcept
    {
        int memcmp_result = memcmp(&a.addr_, &b.addr_, sizeof(::in6_addr));
        if (memcmp_result < 0)
            return true;
        if (memcmp_result > 0)
            return false;
        return a.scope_id_ < b.scope_id_;
    }
    friend constexpr bool operator>(const address_v6& a, const address_v6& b) noexcept { return b < a; }
    friend constexpr bool operator<=(const address_v6& a, const address_v6& b) noexcept { return !(b < a); }
    friend constexpr bool operator>=(const address_v6& a, const address_v6& b) noexcept { return !(a < b); }

private:
    friend class basic_address_iterator<address_v6>;

    ::in6_addr addr_;
    unsigned long scope_id_;
};

template <class CharT, class Traits>
inline basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const address_v6& a)
{
    return s << a.to_string().c_str();
}

constexpr address_v6 make_address_v6(const address_v6::bytes_type& bytes, scope_id_type scope = 0) { return address_v6{ bytes, scope }; }
constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4& a) noexcept
{
    address_v4::bytes_type v4b{ a.to_bytes() };
    address_v6::bytes_type v6b{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, v4b[0], v4b[1], v4b[2], v4b[3] };
    return address_v6{ v6b };
}
address_v6 make_address_v6(const char*, error_code&) noexcept;
inline address_v6 make_address_v6(const char* str)
{
    error_code ec{};
    auto r{ make_address_v6(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline address_v6 make_address_v6(const string& str, error_code& ec) noexcept { return make_address_v6(str.c_str(), ec); }
inline address_v6 make_address_v6(const string& str)
{
    error_code ec{};
    auto r{ make_address_v6(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline address_v6 make_address_v6(string_view str, error_code& ec) noexcept { return make_address_v6(static_cast<string>(str), ec); }
inline address_v6 make_address_v6(string_view str)
{
    error_code ec{};
    auto r{ make_address_v6(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

class address
{
public:
    constexpr address() noexcept : type_(ipv4), v4_(), v6_() {}
    constexpr address(const address& a) noexcept : type_(a.type_), v4_(a.v4_), v6_(a.v6_) {}
    constexpr address(const address_v4& a) noexcept : type_(ipv4), v4_(a), v6_() {}
    constexpr address(const address_v6& a) noexcept : type_(ipv6), v4_(), v6_(a) {}

    address& operator=(const address& a) noexcept
    {
        type_ = a.type_;
        v4_ = a.v4_;
        v6_ = a.v6_;
        return *this;
    }
    address& operator=(const address_v4& a) noexcept
    {
        type_ = ipv4;
        v4_ = a;
        v6_ = {};
        return *this;
    }
    address& operator=(const address_v6& a) noexcept
    {
        type_ = ipv6;
        v4_ = {};
        v6_ = a;
        return *this;
    }

    constexpr bool is_v4() const noexcept { return type_ == ipv4; }
    constexpr bool is_v6() const noexcept { return type_ == ipv6; }
    constexpr address_v4 to_v4() const
    {
        if (type_ != ipv4)
            throw bad_address_cast{};
        else
            return v4_;
    }
    constexpr address_v6 to_v6() const
    {
        if (type_ != ipv6)
            throw bad_address_cast{};
        else
            return v6_;
    }
    constexpr bool is_unspecified() const noexcept { return type_ == ipv4 ? v4_.is_unspecified() : v6_.is_unspecified(); }
    constexpr bool is_loopback() const noexcept { return type_ == ipv4 ? v4_.is_loopback() : v6_.is_loopback(); }
    constexpr bool is_multicast() const noexcept { return type_ == ipv4 ? v4_.is_multicast() : v6_.is_multicast(); }
    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        return type_ == ipv4 ? v4_.to_string(a) : v6_.to_string(a);
    }

    friend constexpr bool operator==(const address& a, const address& b) noexcept
    {
        if (a.type_ != b.type_)
            return false;
        else
        {
            if (a.type_ == address::ipv4)
                return a.v4_ == b.v4_;
            else
                return a.v6_ == b.v6_;
        }
    }
    friend constexpr bool operator!=(const address& a, const address& b) noexcept { return !(a == b); }
    friend constexpr bool operator<(const address& a, const address& b) noexcept
    {
        if (a.type_ != b.type_)
            return a.type_ < b.type_;
        else
        {
            if (a.type_ == address::ipv4)
                return a.v4_ < b.v4_;
            else
                return a.v6_ > b.v6_;
        }
    }
    friend constexpr bool operator>(const address& a, const address& b) noexcept { return b < a; }
    friend constexpr bool operator<=(const address& a, const address& b) noexcept { return !(b < a); }
    friend constexpr bool operator>=(const address& a, const address& b) noexcept { return !(a < b); }

private:
    enum
    {
        ipv4,
        ipv6
    } type_;
    address_v4 v4_;
    address_v6 v6_;
};

template <class CharT, class Traits>
inline basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const address& a)
{
    return s << a.to_string().c_str();
}

address make_address(const char*, error_code&) noexcept;
inline address make_address(const char* str)
{
    error_code ec{};
    auto r{ make_address(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline address make_address(const string& str, error_code& ec) noexcept { return make_address(str.c_str(), ec); }
inline address make_address(const string& str)
{
    error_code ec{};
    auto r{ make_address(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline address make_address(string_view str, error_code& ec) noexcept { return make_address(static_cast<string>(str), ec); }
inline address make_address(string_view str)
{
    error_code ec{};
    auto r{ make_address(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

template <class>
class basic_address_iterator;

template <>
class basic_address_iterator<address_v4>
{
public:
    using value_type = address_v4;
    using difference_type = ptrdiff_t;
    using pointer = const address_v4*;
    using reference = const address_v4&;
    using iterator_category = input_iterator_tag;

    basic_address_iterator(const address_v4& a) noexcept : address_(a) {}

    reference operator*() const noexcept { return address_; }
    pointer operator->() const noexcept { return addressof(address_); }
    basic_address_iterator& operator++() noexcept;
    basic_address_iterator operator++(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        ++(*this);
        return tmp;
    }
    basic_address_iterator& operator--() noexcept;
    basic_address_iterator operator--(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        --(*this);
        return tmp;
    }

    friend bool operator==(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ == b.address_; }
    friend bool operator!=(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ != b.address_; }

private:
    address_v4 address_;
};

using address_v4_iterator = basic_address_iterator<address_v4>;

template <>
class basic_address_iterator<address_v6>
{
public:
    using value_type = address_v6;
    using difference_type = ptrdiff_t;
    using pointer = const address_v6*;
    using reference = const address_v6&;
    using iterator_category = input_iterator_tag;

    basic_address_iterator(const address_v6& a) noexcept : address_(a) {}

    reference operator*() const noexcept { return address_; }
    pointer operator->() const noexcept { return addressof(address_); }
    basic_address_iterator& operator++() noexcept;
    basic_address_iterator operator++(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        ++(*this);
        return tmp;
    }
    basic_address_iterator& operator--() noexcept;
    basic_address_iterator operator--(int) noexcept
    {
        basic_address_iterator tmp{ *this };
        --(*this);
        return tmp;
    }

    friend bool operator==(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ == b.address_; }
    friend bool operator!=(const basic_address_iterator& a, const basic_address_iterator& b) { return a.address_ != b.address_; }

private:
    address_v6 address_;
};

using address_v6_iterator = basic_address_iterator<address_v6>;

template <class>
class basic_address_range;

template <>
class basic_address_range<address_v4>
{
public:
    using iterator = basic_address_iterator<address_v4>;

    basic_address_range() noexcept : begin_({}), end_({}) {}
    basic_address_range(const address_v4& first, const address_v4& last) noexcept : begin_(first), end_(last) {}

    iterator begin() const noexcept { return begin_; }
    iterator end() const noexcept { return end_; }
    bool empty() const noexcept { return size() == 0; }
    size_t size() const noexcept { return end_->to_uint() - begin_->to_uint(); }
    iterator find(const address_v4& addr) const noexcept { return addr >= *begin_ && addr < *end_ ? iterator{ addr } : end_; }

private:
    iterator begin_;
    iterator end_;
};

using address_v4_range = basic_address_range<address_v4>;

template <>
class basic_address_range<address_v6>
{
public:
    using iterator = basic_address_iterator<address_v6>;

    basic_address_range() noexcept : begin_({}), end_({}) {}
    basic_address_range(const address_v6& first, const address_v6& last) noexcept : begin_(first), end_(last) {}
    basic_address_range(iterator begin, iterator end) : begin_(begin), end_(end) {}

    iterator begin() const noexcept { return begin_; }
    iterator end() const noexcept { return end_; }
    bool empty() const noexcept { return begin_ == end_; }
    iterator find(const address_v6& addr) const noexcept { return addr >= *begin_ && addr < *end_ ? iterator{ addr } : end_; }

private:
    iterator begin_;
    iterator end_;
};

using address_v6_range = basic_address_range<address_v6>;

class network_v4
{
public:
    constexpr network_v4() noexcept : address_(), prefix_length_(0) {}
    constexpr network_v4(const address_v4& addr, int prefix_len) : address_(addr), prefix_length_(prefix_len)
    {
        if (prefix_len < 0 || prefix_len > 32)
            throw out_of_range{ "prefix length too large" };
    }
    constexpr network_v4(const address_v4& addr, const address_v4& mask) : address_(addr), prefix_length_(0)
    {
        address_v4::bytes_type mask_bytes{ mask.to_bytes() };
        bool finished = false;
        for (size_t i{ 0 }; i < mask_bytes.size(); ++i)
        {
            if (finished)
            {
                if (mask_bytes[i])
                {
                    throw invalid_argument{ "non-contiguous netmask" };
                }
                continue;
            }
            else
            {
                switch (mask_bytes[i])
                {
                case 255:
                    prefix_length_ += 8;
                    break;
                case 254: // prefix_length_ += 7
                    ++prefix_length_;
                case 252: // prefix_length_ += 6
                    ++prefix_length_;
                case 248: // prefix_length_ += 5
                    ++prefix_length_;
                case 240: // prefix_length_ += 4
                    ++prefix_length_;
                case 224: // prefix_length_ += 3
                    ++prefix_length_;
                case 192: // prefix_length_ += 2
                    ++prefix_length_;
                case 128: // prefix_length_ += 1
                    ++prefix_length_;
                case 0: // nbits += 0
                    finished = true;
                    break;
                default:
                    throw invalid_argument{ "non-contiguous netmask" };
                }
            }
        }
    }

    constexpr address_v4 address() const noexcept { return address_; }
    constexpr int prefix_length() const noexcept { return prefix_length_; }
    constexpr address_v4 netmask() const noexcept
    {
        uint_least32_t nmbits{ 0xffffffff };
        if (prefix_length_ == 0)
            nmbits = 0;
        else
            nmbits = nmbits << (32 - prefix_length_);
        return address_v4{ nmbits };
    }
    constexpr address_v4 network() const noexcept { return address_v4{ address_.to_uint() & netmask().to_uint() }; }
    constexpr address_v4 broadcast() const noexcept { return address_v4{ network().to_uint() | (netmask().to_uint() ^ 0xFFFFFFFF) }; }
    address_v4_range hosts() const noexcept { return is_host() ? address_v4_range{ address_, address_v4{ address_.to_uint() + 1 } } : address_v4_range{ address_v4{ network().to_uint() + 1 }, broadcast() }; }
    constexpr network_v4 canonical() const noexcept { return network_v4{ network(), netmask() }; }
    constexpr bool is_host() const noexcept { return prefix_length_ == 32; }
    constexpr bool is_subnet_of(const network_v4& other) const noexcept
    {
        if (other.prefix_length_ >= prefix_length_)
            return false;
        const network_v4 me{ address_, other.prefix_length_ };
        return other.canonical() == me.canonical();
    }

    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        basic_ostringstream<char, char_traits<char>, Allocator> s{};
        s << address_.to_string(a) << '/' << prefix_length_;
        return s.str();
    }
    template <class CharT, class Traits>
    friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const network_v4& net)
    {
        return s << net.address_.to_string() << '/' << net.prefix_length_;
    }

    friend constexpr bool operator==(const network_v4& a, const network_v4& b) noexcept { return a.address_ == b.address_ && a.prefix_length_ == b.prefix_length_; }
    friend constexpr bool operator!=(const network_v4& a, const network_v4& b) noexcept { return !(a == b); }

private:
    address_v4 address_;
    int prefix_length_;
};

inline network_v4 make_network_v4(const address_v4& addr, int prefix_len) { return network_v4{ addr, prefix_len }; }
inline network_v4 make_network_v4(const address_v4& addr, const address_v4& mask) { return network_v4{ addr, mask }; }
network_v4 make_network_v4(const string&, error_code&) noexcept;
inline network_v4 make_network_v4(const string& str)
{
    error_code ec{};
    auto r{ make_network_v4(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline network_v4 make_network_v4(const char* str, error_code& ec) noexcept { return make_network_v4(string{ str }, ec); }
inline network_v4 make_network_v4(const char* str)
{
    error_code ec{};
    auto r{ make_network_v4(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline network_v4 make_network_v4(string_view str, error_code& ec) noexcept { return make_network_v4(static_cast<string>(str), ec); }
inline network_v4 make_network_v4(string_view str)
{
    error_code ec{};
    auto r{ make_network_v4(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

class network_v6
{
public:
    constexpr network_v6() noexcept : address_(), prefix_length_(0) {}
    constexpr network_v6(const address_v6& addr, int prefix_len) : address_(addr), prefix_length_(prefix_len)
    {
        if (prefix_len < 0 || prefix_len > 128)
            throw out_of_range{ "prefix length too large" };
    }

    constexpr address_v6 address() const noexcept { return address_; }
    constexpr int prefix_length() const noexcept { return prefix_length_; }
    constexpr address_v6 network() const noexcept
    {
        address_v6::bytes_type bytes{ address_.to_bytes() };
        for (size_t i{ 0 }; i < 16; ++i)
        {
            if (prefix_length_ <= i * 8)
                bytes[i] = 0;
            else if (prefix_length_ < (i + 1) * 8)
                bytes[i] &= 0xFF00 >> (prefix_length_ % 8);
        }
        return address_v6{ bytes, address_.scope_id() };
    }
    address_v6_range hosts() const noexcept
    {
        address_v6::bytes_type begin_bytes{ address_.to_bytes() };
        address_v6::bytes_type end_bytes{ address_.to_bytes() };
        for (size_t i{ 0 }; i < 16; ++i)
        {
            if (prefix_length_ <= i * 8)
            {
                begin_bytes[i] = 0;
                end_bytes[i] = 0xFF;
            }
            else if (prefix_length_ < (i + 1) * 8)
            {
                begin_bytes[i] &= 0xFF00 >> (prefix_length_ % 8);
                end_bytes[i] |= 0xFF >> (prefix_length_ % 8);
            }
        }
        return address_v6_range{ address_v6_iterator{ address_v6{ begin_bytes, address_.scope_id() } }, ++address_v6_iterator{ address_v6{ end_bytes, address_.scope_id() } } };
    }
    constexpr network_v6 canonical() const noexcept { return network_v6{ network(), prefix_length() }; }
    constexpr bool is_host() const noexcept { return prefix_length_ == 128; }
    constexpr bool is_subnet_of(const network_v6& other) const noexcept
    {
        if (other.prefix_length_ >= prefix_length_)
            return false;
        const network_v6 me{ address_, other.prefix_length_ };
        return other.canonical() == me.canonical();
    }

    template <class Allocator = allocator<char>>
    basic_string<char, char_traits<char>, Allocator> to_string(const Allocator& a = {}) const
    {
        basic_ostringstream<char, char_traits<char>, Allocator> s{};
        s << address_.to_string(a) << '/' << prefix_length_;
        return s.str();
    }
    template <class CharT, class Traits>
    friend basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& s, const network_v6& net)
    {
        return s << net.address_.to_string() << '/' << net.prefix_length_;
    }

    friend constexpr bool operator==(const network_v6& a, const network_v6& b) noexcept { return a.address_ == b.address_ && a.prefix_length_ == b.prefix_length_; }
    friend constexpr bool operator!=(const network_v6& a, const network_v6& b) noexcept { return !(a == b); }

private:
    address_v6 address_;
    int prefix_length_;
};

inline network_v6 make_network_v6(const address_v6& addr, int prefix_len) { return network_v6{ addr, prefix_len }; }
network_v6 make_network_v6(const string&, error_code&) noexcept;
inline network_v6 make_network_v6(const string& str)
{
    error_code ec{};
    auto r{ make_network_v6(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline network_v6 make_network_v6(const char* str, error_code& ec) noexcept { return make_network_v6(string{ str }, ec); }
inline network_v6 make_network_v6(const char* str)
{
    error_code ec{};
    auto r{ make_network_v6(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}
inline network_v6 make_network_v6(string_view str, error_code& ec) noexcept { return make_network_v6(static_cast<string>(str), ec); }
inline network_v6 make_network_v6(string_view str)
{
    error_code ec{};
    auto r{ make_network_v6(str, ec) };
    _Check_error_code(ec, __func__);
    return r;
}

template <class InternetProtocol>
class basic_endpoint;

template <class InternetProtocol>
bool operator==(const basic_endpoint<InternetProtocol>&, const basic_endpoint<InternetProtocol>&);
template <class InternetProtocol>
bool operator!=(const basic_endpoint<InternetProtocol>&, const basic_endpoint<InternetProtocol>&);
template <class InternetProtocol>
bool operator<(const basic_endpoint<InternetProtocol>&, const basic_endpoint<InternetProtocol>&);
template <class InternetProtocol>
bool operator>(const basic_endpoint<InternetProtocol>&, const basic_endpoint<InternetProtocol>&);
template <class InternetProtocol>
bool operator<=(const basic_endpoint<InternetProtocol>&, const basic_endpoint<InternetProtocol>&);
template <class InternetProtocol>
bool operator>=(const basic_endpoint<InternetProtocol>&, const basic_endpoint<InternetProtocol>&);

template <class CharT, class Traits, class InternetProtocol>
basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>&, const basic_endpoint<InternetProtocol>&);

template <class InternetProtocol>
class basic_resolver_entry;

template <class InternetProtocol>
bool operator==(const basic_resolver_entry<InternetProtocol>&, const basic_resolver_entry<InternetProtocol>&);
template <class InternetProtocol>
bool operator!=(const basic_resolver_entry<InternetProtocol>&, const basic_resolver_entry<InternetProtocol>&);

template <class InternetProtocol>
class basic_resolver_results;

template <class InternetProtocol>
bool operator==(const basic_resolver_results<InternetProtocol>&, const basic_resolver_results<InternetProtocol>&);
template <class InternetProtocol>
bool operator!=(const basic_resolver_results<InternetProtocol>&, const basic_resolver_results<InternetProtocol>&);

class resolver_base;

template <class InternetProtocol>
class basic_resolver;

string host_name();
string host_name(error_code&);
template <class Allocator>
basic_string<char, char_traits<char>, Allocator> host_name(const Allocator&);
template <class Allocator>
basic_string<char, char_traits<char>, Allocator> host_name(const Allocator&, error_code&);

class tcp;

bool operator==(const tcp& a, const tcp& b);
bool operator!=(const tcp& a, const tcp& b);

class udp;

bool operator==(const udp& a, const udp& b);
bool operator!=(const udp& a, const udp& b);

class v6_only;

namespace unicast
{
class hops;
}

namespace multicast
{
class join_group;
class leave_group;
class outbound_interface;
class hops;
class enable_loopback;
} // namespace multicast
} // namespace ip
} // namespace v1
} // namespace experimental::net
template <>
struct is_error_condition_enum<experimental::net::v1::ip::resolver_errc> : public true_type
{
};

template <>
struct hash<experimental::net::v1::ip::address>;
template <>
struct hash<experimental::net::v1::ip::address_v4>;
template <>
struct hash<experimental::net::v1::ip::address_v6>;
} // namespace std

#endif
