#ifndef NET_SOCKET
#define NET_SOCKET

#include <experimental/timer>

#include <WinSock2.h>
#include <system_error>
#include <type_traits>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class socket_errc
{
    already_open = 1,
    not_found = 3
};

struct _Socket_category : error_category
{
    const char* name() const noexcept override { return "socket"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(socket_errc::already_open):
            return "Already open";
        case static_cast<int>(socket_errc::not_found):
            return "Element not found";
        default:
            return "socket error";
        }
    }
};

inline const error_category& socket_category() noexcept
{
    static _Socket_category instance{};
    return instance;
}

inline error_code make_error_code(socket_errc e) noexcept { return error_code{ static_cast<int>(e), socket_category() }; }
inline error_condition make_error_condition(socket_errc e) noexcept { return error_condition{ static_cast<int>(e), socket_category() }; }

class socket_base
{
public:
    class broadcast
    {
    };
    class debug
    {
    };
    class do_not_route
    {
    };
    class keep_alive
    {
    };
    class out_of_band_inline
    {
    };
    class receive_buffer_size
    {
    };
    class receive_low_watermark
    {
    };
    class reuse_address
    {
    };
    class send_buffer_size
    {
    };
    class send_low_watermark
    {
    };

    class linger
    {
    public:
        linger() noexcept = default;
        linger(bool e, chrono::seconds t) noexcept
        {
            enabled(e);
            timeout(t);
        };

        bool enabled() const noexcept { return value_.l_onoff; }
        void enabled(bool e) noexcept { value_.l_onoff = u_short(e); }

        chrono::seconds timeout() const noexcept { return chrono::seconds{ value_.l_linger }; }
        void timeout(chrono::seconds t) noexcept { value_.l_linger = (u_short)t.count(); }

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            reyurn SO_LINGER;
        }
        template <class Protocol>
        void data(const Protocol&) noexcept
        {
            return &value_;
        }
        template <class Protocol>
        const void* data(const Protocol&) const noexcept
        {
            return &value_;
        }
        template <class Protocol>
        size_t size(const Protocol&) const noexcept
        {
            return sizeof(value_);
        }
        template <class Protocol>
        void resize(const Protocol&, size_t s)
        {
            if (s != sizeof(value_))
                throw length_error{ "size exceeded" };
        }

    private:
        ::linger value_;
    };

    enum class shutdown_type
    {
        shutdown_receive = 0, // SHUT_RD
        shutdown_send = 1, // SHUT_WR
        shutdown_both = 2 // SHUT_RDWR
    };
    static constexpr shutdown_type shutdown_receive{ shutdown_type::shutdown_receive };
    static constexpr shutdown_type shutdown_send{ shutdown_type::shutdown_send };
    static constexpr shutdown_type shutdown_both{ shutdown_type::shutdown_both };

    enum class wait_type
    {
        wait_read,
        wait_write,
        wait_error
    };
    static constexpr wait_type wait_read{ wait_type::wait_read };
    static constexpr wait_type wait_write{ wait_type::wait_write };
    static constexpr wait_type wait_error{ wait_type::wait_error };

    enum class message_flags
    {
        message_peek = 0x02, // MSG_PEEK
        message_out_of_band = 0x01, // MSG_OOB
        message_do_not_route = 0x04 // MSG_DONTROUTE
    };
    static constexpr message_flags message_peek{ message_flags::message_peek };
    static constexpr message_flags message_out_of_band{ message_flags::message_out_of_band };
    static constexpr message_flags message_do_not_route{ message_flags::message_do_not_route };

    static const int max_listen_connections{ 128 };

protected:
    socket_base() = default;
    ~socket_base() = default;
};

template <class Protocol>
class basic_socket
{
public:
    using executor_type = io_context::executor_type;
    using native_handle_type = SOCKET;
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    executor_type get_executor() noexcept { return ctx_->get_executor(); }
    native_handle_type native_handle() { return socket_; }

    void open(const protocol_type& protocol, error_code& ec)
    {
        if (is_open())
            ec = make_error_code(socket_errc::already_open);
        else
        {
            protocol_ = protocol;
            socket_ = ::socket(protocol.family(), protocol.type(), protocol.protocol());
            if (is_open())
            {
                ec = error_code{};
            }
            else
            {
                ec = error_code{ ::WSAGetLastError(), generic_category() };
            }
        }
    }
    void open(const protocol_type& protocol = {}) { _CHECK_ERROR_CODE_INVOKE(open(protocol, ec)); }
    void assign(const protocol_type& protocol, const native_handle_type& native_socket, error_code& ec)
    {
        if (is_open())
            ec = make_error_code(socket_errc::already_open);
        else
        {
            protocol_ = protocol;
            socket_ = native_socket;
            if (is_open())
            {
                ec = error_code{};
            }
            else
            {
                ec = error_code{ ::WSAGetLastError(), generic_category() };
            }
        }
    }

    void assign(const protocol_type& protocol, const native_handle_type& native_socket) { _CHECK_ERROR_CODE_INVOKE(assign(protocol, native_socket, ec)); }
    native_handle_type release(error_code&)
    {
        return socket_;
    }
    native_handle_type release() { _CHECK_ERROR_CODE_INVOKE_FUNC(release(ec)); }

    bool is_open() const noexcept { return socket_ != INVALID_SOCKET; }

    void close(error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else
        {
            int r{ ::closesocket(socket_) };
            if (r != 0)
                ec = error_code{ ::WSAGetLastError(), generic_category() };
        }
    }
    void close() { _CHECK_ERROR_CODE_INVOKE(close(ec)); }

    void cancel(error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
    }
    void cancel() { _CHECK_ERROR_CODE_INVOKE(cancel(ec)); }

    template <class SettableSocketOption>
    void set_option(const SettableSocketOption& option, error_code& ec);
    template <class SettableSocketOption>
    void set_option(const SettableSocketOption& option)
    {
        _CHECK_ERROR_CODE_INVOKE(set_option(option, ec));
    }

    template <class GettableSocketOption>
    void get_option(GettableSocketOption& option, error_code& ec) const;
    template <class GettableSocketOption>
    void get_option(GettableSocketOption& option) const
    {
        _CHECK_ERROR_CODE_INVOKE(get_option(option, ec));
    }

    template <class IoControlCommand>
    void io_control(IoControlCommand& command, error_code& ec);
    template <class IoControlCommand>
    void io_control(IoControlCommand& command)
    {
        _CHECK_ERROR_CODE_INVOKE(io_control(command, ec));
    }

    void non_blocking(bool mode, error_code& ec);
    void non_blocking(bool mode) { _CHECK_ERROR_CODE_INVOKE(non_blocking(mode, ec)); }
    bool non_blocking() const;

    void native_non_blocking(bool mode, error_code& ec);
    void native_non_blocking(bool mode) { _CHECK_ERROR_CODE_INVOKE(native_non_blocking(mode, ec)); }
    bool native_non_blocking() const;

    bool at_mark() const;
    bool at_mark(error_code& ec) const;

    size_t available(error_code& ec) const;
    size_t available() const { _CHECK_ERROR_CODE_INVOKE_FUNC(avaliable(ec)); }

    void bind(const endpoint_type& endpoint, error_code& ec);
    void bind(const endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE(bind(endpoint, ec)); }

    void shutdown(shutdown_type what, error_code& ec);
    void shutdown(shutdown_type what) { _CHECK_ERROR_CODE_INVOKE(shutdown(what, ec)); }

    endpoint_type local_endpoint(error_code& ec) const;
    endpoint_type local_endpoint() const { _CHECK_ERROR_CODE_INVOKE_FUNC(local_endpoint(ec)); }

    endpoint_type remote_endpoint() const;
    endpoint_type remote_endpoint(error_code& ec) const;

    void connect(const endpoint_type& endpoint, error_code& ec);
    void connect(const endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE(connect(endpoint, ec)); }

    template <class CompletionToken>
    auto async_connect(const endpoint_type& endpoint, CompletionToken&& token);

    void wait(wait_type w, error_code& ec);
    void wait(wait_type w) { _CHECK_ERROR_CODE_INVOKE(wait(w, ec)); }

    template <class CompletionToken>
    auto async_wait(wait_type w, CompletionToken&& token);

protected:
    explicit basic_socket(io_context& ctx) : ctx_(&ctx), socket_(INVALID_SOCKET) {}
    basic_socket(io_context& ctx, const protocol_type& protocol) : ctx_(&ctx), protocol_(protocol) { open(protocol); }
    basic_socket(io_context& ctx, const endpoint_type& endpoint) : ctx_(&ctx)
    {
        open(endpoint.protocol());
        bind(endpoint);
    }
    basic_socket(io_context& ctx, const protocol_type& protocol, const native_handle_type& native_socket) : ctx_(&ctx), protocol_(protocol), socket_(native_socket) {}
    basic_socket(const basic_socket&) = delete;
    basic_socket(basic_socket&& rhs) : ctx_(rhs.ctx_), protocol_(rhs.protocol_), socket_(rhs.socket_) { rhs.socket_ = INVALID_SOCKET; }
    template <class OtherProtocol>
    basic_socket(basic_socket<OtherProtocol>&& rhs) : ctx_(rhs.ctx_), protocol_(rhs.protocol_), socket_(rhs.socket_)
    {
        rhs.socket_ = INVALID_SOCKET;
    }

    ~basic_socket()
    {
        if (is_open())
        {
            int r{ ::closesocket(socket_) };
        }
    }

    basic_socket& operator=(const basic_socket&) = delete;
    basic_socket& operator=(basic_socket&& rhs)
    {
        ctx_ = rhs.ctx_;
        protocol_ = rhs.protocol_;
        socket_ = rhs.socket_;
        rhs.socket_ = INVALID_SOCKET;
        return *this;
    }
    template <class OtherProtocol>
    basic_socket& operator=(basic_socket<OtherProtocol>&& rhs)
    {
        ctx_ = rhs.ctx_;
        protocol_ = rhs.protocol_;
        socket_ = rhs.socket_;
        rhs.socket_ = INVALID_SOCKET;
        return *this;
    }

private:
    io_context* ctx_;
    protocol_type protocol_;
    SOCKET socket_;
};

template <class Protocol>
class basic_datagram_socket;

template <class Protocol>
class basic_stream_socket;

template <class Protocol>
class basic_socket_acceptor;

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_streambuf;

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_iostream;

template <class Protocol, class EndpointSequence>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints);
template <class Protocol, class EndpointSequence>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, error_code& ec);
template <class Protocol, class EndpointSequence, class ConnectCondition>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c);
template <class Protocol, class EndpointSequence, class ConnectCondition>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, error_code& ec);

template <class Protocol, class InputIterator>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last);
template <class Protocol, class InputIterator>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, error_code& ec);
template <class Protocol, class InputIterator, class ConnectCondition>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c);
template <class Protocol, class InputIterator, class ConnectCondition>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, error_code& ec);

template <class Protocol, class EndpointSequence, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, CompletionToken&& token);
template <class Protocol, class EndpointSequence, class ConnectCondition, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, CompletionToken&& token);

template <class Protocol, class InputIterator, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, CompletionToken&& token);
template <class Protocol, class InputIterator, class ConnectCondition, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, CompletionToken&& token);

} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::socket_errc> : public true_type
{
};
} // namespace std

#endif
