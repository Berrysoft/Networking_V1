#ifndef NET_SOCKET
#define NET_SOCKET

#include <experimental/timer>
#include <system_error>
#include <type_traits>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class socket_errc
{
    already_open = 1,
    not_found = 3
};

struct _Socket_category : error_category
{
    const char* name() const noexcept override { return "socket"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(socket_errc::already_open):
            return "Already open";
        case static_cast<int>(socket_errc::not_found):
            return "Element not found";
        default:
            return "socket error";
        }
    }
};

inline const error_category& socket_category() noexcept
{
    static _Socket_category instance{};
    return instance;
}

inline error_code make_error_code(socket_errc e) noexcept { return error_code{ static_cast<int>(e), socket_category() }; }
inline error_condition make_error_condition(socket_errc e) noexcept { return error_condition{ static_cast<int>(e), socket_category() }; }

class socket_base
{
public:
    class broadcast
    {
    };
    class debug
    {
    };
    class do_not_route
    {
    };
    class keep_alive
    {
    };
    class out_of_band_inline
    {
    };
    class receive_buffer_size
    {
    };
    class receive_low_watermark
    {
    };
    class reuse_address
    {
    };
    class send_buffer_size
    {
    };
    class send_low_watermark
    {
    };

    class linger
    {
    public:
        linger() noexcept;
        linger(bool e, chrono::seconds t) noexcept;

        bool enabled() const noexcept;
        void enabled(bool e) noexcept;

        chrono::seconds timeout() const noexcept;
        void timeout(chrono::seconds t) noexcept;
    };

    enum class shutdown_type
    {
        shutdown_receive = 0, // SHUT_RD
        shutdown_send = 1, // SHUT_WR
        shutdown_both = 2 // SHUT_RDWR
    };
    static constexpr shutdown_type shutdown_receive{ shutdown_type::shutdown_receive };
    static constexpr shutdown_type shutdown_send{ shutdown_type::shutdown_send };
    static constexpr shutdown_type shutdown_both{ shutdown_type::shutdown_both };

    enum class wait_type
    {
        wait_read,
        wait_write,
        wait_error
    };
    static constexpr wait_type wait_read{ wait_type::wait_read };
    static constexpr wait_type wait_write{ wait_type::wait_write };
    static constexpr wait_type wait_error{ wait_type::wait_error };

    enum class message_flags
    {
        message_peek = 0x02, // MSG_PEEK
        message_out_of_band = 0x01, // MSG_OOB
        message_do_not_route = 0x04 // MSG_DONTROUTE
    };
    static constexpr message_flags message_peek{ message_flags::message_peek };
    static constexpr message_flags message_out_of_band{ message_flags::message_out_of_band };
    static constexpr message_flags message_do_not_route{ message_flags::message_do_not_route };

    static const int max_listen_connections{ 128 };

protected:
    socket_base();
    ~socket_base();
};

template <class Protocol>
class basic_socket;

template <class Protocol>
class basic_datagram_socket;

template <class Protocol>
class basic_stream_socket;

template <class Protocol>
class basic_socket_acceptor;

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_streambuf;

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_iostream;

template <class Protocol, class EndpointSequence>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints);
template <class Protocol, class EndpointSequence>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, error_code& ec);
template <class Protocol, class EndpointSequence, class ConnectCondition>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c);
template <class Protocol, class EndpointSequence, class ConnectCondition>
typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, error_code& ec);

template <class Protocol, class InputIterator>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last);
template <class Protocol, class InputIterator>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, error_code& ec);
template <class Protocol, class InputIterator, class ConnectCondition>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c);
template <class Protocol, class InputIterator, class ConnectCondition>
InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, error_code& ec);

template <class Protocol, class EndpointSequence, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, CompletionToken&& token);
template <class Protocol, class EndpointSequence, class ConnectCondition, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, CompletionToken&& token);

template <class Protocol, class InputIterator, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, CompletionToken&& token);
template <class Protocol, class InputIterator, class ConnectCondition, class CompletionToken>
auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, CompletionToken&& token);

} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::socket_errc> : public true_type
{
};
} // namespace std

#endif
