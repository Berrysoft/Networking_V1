#ifndef NET_SOCKET
#define NET_SOCKET

#include <experimental/timer>

#include <WinSock2.h>
#include <istream>
#include <streambuf>
#include <system_error>
#include <type_traits>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class socket_errc
{
    already_open = 1,
    not_found = 3
};

struct _Socket_category : error_category
{
    const char* name() const noexcept override { return "socket"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(socket_errc::already_open):
            return "Already open";
        case static_cast<int>(socket_errc::not_found):
            return "Element not found";
        default:
            return "socket error";
        }
    }
};

inline const error_category& socket_category() noexcept
{
    static _Socket_category instance{};
    return instance;
}

inline error_code make_error_code(socket_errc e) noexcept { return error_code{ static_cast<int>(e), socket_category() }; }
inline error_condition make_error_condition(socket_errc e) noexcept { return error_condition{ static_cast<int>(e), socket_category() }; }

class socket_base
{
public:
    template <typename Base>
    class _Option_base
    {
    public:
        _Option() noexcept = default;
        _Option(Base val) : value_(val) {}

        template <class Protocol>
        void* data(const Protocol&) noexcept
        {
            return &value_;
        }
        template <class Protocol>
        const void* data(const Protocol&) const noexcept
        {
            return &value_;
        }
        template <class Protocol>
        size_t size(const Protocol&) const noexcept
        {
            return sizeof(value_);
        }
        template <class Protocol>
        void resize(const Protocol&, size_t s)
        {
            if (s != sizeof(value_))
                throw length_error{ "size exceeded" };
        }

    protected:
        Base value_;
    };
    class broadcast : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_BROADCAST;
        }
    };
    class debug : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_DEBUG;
        }
    };
    class do_not_route : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_DONTROUTE;
        }
    };
    class keep_alive : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_KEEPALIVE;
        }
    };
    class out_of_band_inline : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_OOBINLINE;
        }
    };
    class receive_buffer_size : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_RCVBUF;
        }
    };
    class receive_low_watermark : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_RCVLOWAT;
        }
    };
    class reuse_address : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_REUSEADDR;
        }
    };
    class send_buffer_size : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_SNDBUF;
        }
    };
    class send_low_watermark : _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_SNDLOWAT;
        }
    };

    class linger : _Option_base<::linger>
    {
    public:
        using _Option_base<::linger>::_Option_base;

        linger(bool e, chrono::seconds t) noexcept
        {
            enabled(e);
            timeout(t);
        };

        bool enabled() const noexcept { return value_.l_onoff; }
        void enabled(bool e) noexcept { value_.l_onoff = u_short(e); }

        chrono::seconds timeout() const noexcept { return chrono::seconds{ value_.l_linger }; }
        void timeout(chrono::seconds t) noexcept { value_.l_linger = (u_short)t.count(); }

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_LINGER;
        }
    };

    enum class shutdown_type
    {
        shutdown_receive = SD_RECEIVE,
        shutdown_send = SD_SEND,
        shutdown_both = SD_BOTH
    };
    static constexpr shutdown_type shutdown_receive{ shutdown_type::shutdown_receive };
    static constexpr shutdown_type shutdown_send{ shutdown_type::shutdown_send };
    static constexpr shutdown_type shutdown_both{ shutdown_type::shutdown_both };

    enum class wait_type
    {
        wait_read = POLLIN,
        wait_write = POLLOUT,
        wait_error = POLLERR
    };
    static constexpr wait_type wait_read{ wait_type::wait_read };
    static constexpr wait_type wait_write{ wait_type::wait_write };
    static constexpr wait_type wait_error{ wait_type::wait_error };

    enum class message_flags
    {
        message_peek = 0x02, // MSG_PEEK
        message_out_of_band = 0x01, // MSG_OOB
        message_do_not_route = 0x04 // MSG_DONTROUTE
    };
    static constexpr message_flags message_peek{ message_flags::message_peek };
    static constexpr message_flags message_out_of_band{ message_flags::message_out_of_band };
    static constexpr message_flags message_do_not_route{ message_flags::message_do_not_route };

    static const int max_listen_connections{ 128 };

protected:
    socket_base() = default;
    ~socket_base() = default;
};

template <class Protocol>
class _Basic_socket : public socket_base
{
public:
    using executor_type = io_context::executor_type;
    using native_handle_type = SOCKET;
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    executor_type get_executor() noexcept { return ctx_->get_executor(); }
    io_context& _Context() { return *ctx_; }
    native_handle_type native_handle() { return socket_; }
    protocol_type _Protocol() { return protocol_; }

    void open(const protocol_type& protocol, error_code& ec)
    {
        if (is_open())
            ec = make_error_code(socket_errc::already_open);
        else
        {
            protocol_ = protocol;
            socket_ = ::socket(protocol.family(), protocol.type(), protocol.protocol());
            if (is_open())
            {
                ec = error_code{};
            }
            else
            {
                ec = error_code{ ::WSAGetLastError(), generic_category() };
            }
        }
    }
    void open(const protocol_type& protocol = {}) { _CHECK_ERROR_CODE_INVOKE(open(protocol, ec)); }

    void assign(const protocol_type& protocol, const native_handle_type& native_socket, error_code& ec)
    {
        if (is_open())
            ec = make_error_code(socket_errc::already_open);
        else
        {
            protocol_ = protocol;
            socket_ = native_socket;
            if (is_open())
            {
                ec = error_code{};
            }
            else
            {
                ec = error_code{ ::WSAGetLastError(), generic_category() };
            }
        }
    }
    void assign(const protocol_type& protocol, const native_handle_type& native_socket) { _CHECK_ERROR_CODE_INVOKE(assign(protocol, native_socket, ec)); }

    native_handle_type release(error_code&)
    {
        return socket_;
    }
    native_handle_type release() { _CHECK_ERROR_CODE_INVOKE_FUNC(release(ec)); }

    bool is_open() const noexcept { return socket_ != INVALID_SOCKET; }

    void close(error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else
        {
            int r{ ::closesocket(socket_) };
            if (r != 0)
                ec = error_code{ ::WSAGetLastError(), generic_category() };
        }
    }
    void close() { _CHECK_ERROR_CODE_INVOKE(close(ec)); }

    void cancel(error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
    }
    void cancel() { _CHECK_ERROR_CODE_INVOKE(cancel(ec)); }

    template <class SettableSocketOption>
    void set_option(const SettableSocketOption& option, error_code& ec)
    {
        int r{ ::setsockopt(socket_, option.level(protocol_), option.name(protocol_), option.data(protocol_), option.size(protocol_)) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    template <class SettableSocketOption>
    void set_option(const SettableSocketOption& option)
    {
        _CHECK_ERROR_CODE_INVOKE(set_option(option, ec));
    }

    template <class GettableSocketOption>
    void get_option(GettableSocketOption& option, error_code& ec) const
    {
        int option_len{ option.size(protocol_) };
        int r{ ::getsockopt(socket_, option.level(protocol_), option.name(protocol_), option.data(protocol_), &option_len) };
        if (r == 0)
            option.resize(option_len);
        else
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    template <class GettableSocketOption>
    void get_option(GettableSocketOption& option) const
    {
        _CHECK_ERROR_CODE_INVOKE(get_option(option, ec));
    }

    template <class IoControlCommand>
    void io_control(IoControlCommand& command, error_code& ec)
    {
        int r{ ::ioctlsocket(native_handle(), command.name(), command.data()) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    template <class IoControlCommand>
    void io_control(IoControlCommand& command)
    {
        _CHECK_ERROR_CODE_INVOKE(io_control(command, ec));
    }

    void non_blocking(bool mode, error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else
        {
            mode_ = mode ? _Blocking_mode::non_blocking : _Blocking_mode::blocking;
        }
    }
    void non_blocking(bool mode) { _CHECK_ERROR_CODE_INVOKE(non_blocking(mode, ec)); }
    bool non_blocking() const { return mode_ != _Blocking_mode::non_blocking; }

    void native_non_blocking(bool mode, error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else if (!mode && non_blocking())
            ec = make_error_code(errc::invalid_argument);
        else
        {
            unsigned long m = mode ? 0 : 1;
            int r{ ::ioctlsocket(socket_, FIONBIO, &m) };
            mode_ = mode ? _Blocking_mode::native_non_blocking : _Blocking_mode::non_blocking;
            if (r != 0)
                ec = error_code{ ::WSAGetLastError(), generic_category() };
        }
    }
    void native_non_blocking(bool mode) { _CHECK_ERROR_CODE_INVOKE(native_non_blocking(mode, ec)); }
    bool native_non_blocking() const { return mode_ == _Blocking_mode::native_non_blocking; }

    void bind(const endpoint_type& endpoint, error_code& ec)
    {
        int r{ ::bind(socket_, endpoint.data(), endpoint.size()) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void bind(const endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE(bind(endpoint, ec)); }

    endpoint_type local_endpoint(error_code& ec) const
    {
        endpoint_type endpoint{};
        int endpoint_len{ endpoint.capacity() };
        int r{ ::getsockname(socket_, endpoint.data(), &endpoint_len) };
        if (r == 0)
            endpoint.resize(endpoint_len);
        else
        {
            ec = error_code{ ::WSAGetLastError(), generic_category() };
            return {};
        }
        return endpoint;
    }
    endpoint_type local_endpoint() const { _CHECK_ERROR_CODE_INVOKE_FUNC(local_endpoint(ec)); }

    void wait(wait_type w, error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else
        {
            pollfd fd{};
            fd.fd = socket_;
            fd.events = static_cast<SHORT>(w);
            fd.revents = 0;
            int r{ ::WSAPoll(&fd, 1, -1) };
            if (r == SOCKET_ERROR)
                ec = error_code{ ::WSAGetLastError(), generic_category() };
        }
    }
    void wait(wait_type w) { _CHECK_ERROR_CODE_INVOKE(wait(w, ec)); }

    template <class CompletionToken>
    auto async_wait(wait_type w, CompletionToken&& token);

protected:
    explicit _Basic_socket(io_context& ctx) : ctx_(&ctx), socket_(INVALID_SOCKET), mode_(_Blocking_mode::blocking) {}
    _Basic_socket(io_context& ctx, const protocol_type& protocol) : ctx_(&ctx), protocol_(protocol), mode_(_Blocking_mode::blocking) { open(protocol); }
    _Basic_socket(io_context& ctx, const protocol_type& protocol, const native_handle_type& native_socket) : ctx_(&ctx), protocol_(protocol), socket_(native_socket), mode_(_Blocking_mode::blocking) {}
    _Basic_socket(const _Basic_socket&) = delete;
    _Basic_socket(_Basic_socket&& rhs) : ctx_(rhs.ctx_), protocol_(rhs.protocol_), socket_(rhs.socket_), mode_(rhs.mode_) { rhs.socket_ = INVALID_SOCKET; }
    template <class OtherProtocol>
    _Basic_socket(_Basic_socket<OtherProtocol>&& rhs) : ctx_(rhs.ctx_), protocol_(rhs.protocol_), socket_(rhs.socket_), mode_(rhs.mode)
    {
        rhs.socket_ = INVALID_SOCKET;
    }

    virtual ~_Basic_socket()
    {
        if (is_open())
        {
            int r{ ::closesocket(socket_) };
        }
    }

    _Basic_socket& operator=(const _Basic_socket&) = delete;
    _Basic_socket& operator=(_Basic_socket&& rhs)
    {
        ctx_ = rhs.ctx_;
        protocol_ = rhs.protocol_;
        socket_ = rhs.socket_;
        rhs.socket_ = INVALID_SOCKET;
        mode_ = rhs.mode_;
        return *this;
    }
    template <class OtherProtocol>
    _Basic_socket& operator=(_Basic_socket<OtherProtocol>&& rhs)
    {
        ctx_ = rhs.ctx_;
        protocol_ = rhs.protocol_;
        socket_ = rhs.socket_;
        rhs.socket_ = INVALID_SOCKET;
        mode_ = rhs.mode_;
        return *this;
    }

private:
    io_context* ctx_;
    protocol_type protocol_;
    SOCKET socket_;
    enum class _Blocking_mode
    {
        blocking,
        non_blocking,
        native_non_blocking
    } mode_;
};

template <class Protocol>
class basic_socket : public _Basic_socket<Protocol>
{
public:
    bool at_mark(error_code& ec) const
    {
        unsigned long value;
        int r{ ::ioctlsocket(native_handle(), SIOCATMARK, &value) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return value != 0;
    }
    bool at_mark() const { return _CHECK_ERROR_CODE_INVOKE_FUNC(at_mark(ec)); }

    size_t available(error_code& ec) const
    {
        unsigned long value;
        int r{ ::ioctlsocket(native_handle(), FIONREAD, &value) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return static_cast<size_t>(value);
    }
    size_t available() const { _CHECK_ERROR_CODE_INVOKE_FUNC(avaliable(ec)); }

    void shutdown(shutdown_type what, error_code& ec)
    {
        int r{ ::shutdown(native_handle(), static_cast<int>(what)) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void shutdown(shutdown_type what) { _CHECK_ERROR_CODE_INVOKE(shutdown(what, ec)); }

    endpoint_type remote_endpoint() const
    {
        endpoint_type endpoint{};
        int endpoint_len{ endpoint.capacity() };
        int r{ ::getpeername(native_handle(), endpoint.data(), &endpoint_len) };
        if (r == 0)
            endpoint.resize(endpoint_len);
        else
        {
            ec = error_code{ ::WSAGetLastError(), generic_category() };
            return {};
        }
        return endpoint;
    }

    endpoint_type remote_endpoint(error_code& ec) const;

    void connect(const endpoint_type& endpoint, error_code& ec)
    {
        if (!is_open())
        {
            open(endpoint.protocol(), ec);
            if (ec)
                return;
        }
        int r{ ::connect(native_handle(), endpoint.data(), endpoint.size()) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void connect(const endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE(connect(endpoint, ec)); }

    template <class CompletionToken>
    auto async_connect(const endpoint_type& endpoint, CompletionToken&& token);

protected:
    using _Basic_socket<Protocol>::_Basic_socket;
    basic_socket(io_context& ctx, const endpoint_type& endpoint) : _Basic_socket<Protocol>(ctx)
    {
        open(endpoint.protocol());
        bind(endpoint);
    }
};

template <class Protocol>
class basic_datagram_socket : public basic_socket<Protocol>
{
public:
    using native_handle_type = SOCKET;
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    explicit basic_datagram_socket(io_context& ctx);
    basic_datagram_socket(io_context& ctx, const protocol_type& protocol);
    basic_datagram_socket(io_context& ctx, const endpoint_type& endpoint);
    basic_datagram_socket(io_context& ctx, const protocol_type& protocol, const native_handle_type& native_socket);
    basic_datagram_socket(const basic_datagram_socket&) = delete;
    basic_datagram_socket(basic_datagram_socket&& rhs);
    template <class OtherProtocol>
    basic_datagram_socket(basic_datagram_socket<OtherProtocol>&& rhs);

    ~basic_datagram_socket();

    basic_datagram_socket& operator=(const basic_datagram_socket&) = delete;
    basic_datagram_socket& operator=(basic_datagram_socket&& rhs);
    template <class OtherProtocol>
    basic_datagram_socket& operator=(basic_datagram_socket<OtherProtocol>&& rhs);

    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers);
    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, error_code& ec);

    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, message_flags flags);
    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, message_flags flags, error_code& ec);

    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive(const MutableBufferSequence& buffers, CompletionToken&& token);
    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive(const MutableBufferSequence& buffers, message_flags flags, CompletionToken&& token);

    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender);
    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, error_code& ec);

    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, message_flags flags);
    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, message_flags flags, error_code& ec);

    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, CompletionToken&& token);

    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, message_flags flags, CompletionToken&& token);

    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers);
    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, error_code& ec);

    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, message_flags flags);
    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, message_flags flags, error_code& ec);

    template <class ConstBufferSequence, class CompletionToken>
    auto async_send(const ConstBufferSequence& buffers, CompletionToken&& token);
    template <class ConstBufferSequence, class CompletionToken>
    auto async_send(const ConstBufferSequence& buffers, message_flags flags, CompletionToken&& token);

    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient);
    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, error_code& ec);

    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, message_flags flags);
    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, message_flags flags, error_code& ec);

    template <class ConstBufferSequence, class CompletionToken>
    auto async_send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, CompletionToken&& token);
    template <class ConstBufferSequence, class CompletionToken>
    auto async_send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, message_flags flags, CompletionToken&& token);
};

template <class Protocol>
class basic_stream_socket : public basic_socket<Protocol>
{
public:
    using native_handle_type = SOCKET;
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    explicit basic_stream_socket(io_context& ctx);
    basic_stream_socket(io_context& ctx, const protocol_type& protocol);
    basic_stream_socket(io_context& ctx, const endpoint_type& endpoint);
    basic_stream_socket(io_context& ctx, const protocol_type& protocol, const native_handle_type& native_socket);
    basic_stream_socket(const basic_stream_socket&) = delete;
    basic_stream_socket(basic_stream_socket&& rhs);
    template <class OtherProtocol>
    basic_stream_socket(basic_stream_socket<OtherProtocol>&& rhs);

    ~basic_stream_socket();

    basic_stream_socket& operator=(const basic_stream_socket&) = delete;
    basic_stream_socket& operator=(basic_stream_socket&& rhs);
    template <class OtherProtocol>
    basic_stream_socket& operator=(basic_stream_socket<OtherProtocol>&& rhs);

    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers);
    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, error_code& ec);

    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, message_flags flags);
    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, message_flags flags, error_code& ec);

    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive(const MutableBufferSequence& buffers, CompletionToken&& token);

    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive(const MutableBufferSequence& buffers, message_flags flags, CompletionToken&& token);

    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers);
    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, error_code& ec);

    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, message_flags flags);
    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, message_flags flags, error_code& ec);

    template <class ConstBufferSequence, class CompletionToken>
    auto async_send(const ConstBufferSequence& buffers, CompletionToken&& token);

    template <class ConstBufferSequence, class CompletionToken>
    auto async_send(const ConstBufferSequence& buffers, message_flags flags, CompletionToken&& token);

    template <class MutableBufferSequence>
    size_t read_some(const MutableBufferSequence& buffers);
    template <class MutableBufferSequence>
    size_t read_some(const MutableBufferSequence& buffers, error_code& ec);

    template <class MutableBufferSequence, class CompletionToken>
    auto async_read_some(const MutableBufferSequence& buffers, CompletionToken&& token);

    template <class ConstBufferSequence>
    size_t write_some(const ConstBufferSequence& buffers);
    template <class ConstBufferSequence>
    size_t write_some(const ConstBufferSequence& buffers, error_code& ec);

    template <class ConstBufferSequence, class CompletionToken>
    auto async_write_some(const ConstBufferSequence& buffers, CompletionToken&& token);
};

template <class AcceptableProtocol>
class basic_socket_acceptor : public _Basic_socket<AcceptableProtocol>
{
public:
    using socket_type = typename protocol_type::socket;

    using _Basic_socket<AcceptableProtocol>::_Basic_socket;
    basic_socket_acceptor(io_context& ctx, const endpoint_type& endpoint, bool reuse_addr = true) : _Basic_socket<AcceptableProtocol>(ctx)
    {
        open(endpoint.protocol());
        if (reuse_addr)
            set_option(reuse_address{ int(true) });
        bind(endpoint);
        listen();
    }

    void listen(int backlog, error_code& ec)
    {
        int r{ ::listen(native_handle(), backlog) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void listen(int backlog = max_listen_connections) { _CHECK_ERROR_CODE_INVOKE(listen(backlog, ec)); }

    void enable_connection_aborted(bool mode);
    bool enable_connection_aborted() const;

    socket_type accept(io_context& ctx, error_code& ec)
    {
        native_handle_type h{ ::accept(native_handle(), nullptr, 0) };
        if (h != INVALID_SOCKET)
            return socket_type{ ctx, _Protocol(), h };
        else
            return socket_type{ ctx };
    }
    socket_type accept(io_context& ctx) { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(ctx, ec)); }
    socket_type accept(error_code& ec) { accept(_Context(), ec); }
    socket_type accept() { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(ec)); }

    template <class CompletionToken>
    auto async_accept(io_context& ctx, CompletionToken&& token);
    template <class CompletionToken>
    auto async_accept(CompletionToken&& token)
    {
        return accept(_Context(), forward<CompletionToken>(token));
    }

    socket_type accept(io_context& ctx, endpoint_type& endpoint, error_code& ec)
    {
        int endpoint_len{ endpoint.capacity() };
        native_handle_type h{ ::accept(native_handle(), endpoint.data(), &endpoint_len) };
        if (h != INVALID_SOCKET)
        {
            endpoint.resize(endpoint_len);
            return socket_type{ ctx, _Protocol(), h };
        }
        else
        {
            return socket_type{ ctx };
        }
    }
    socket_type accept(io_context& ctx, endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(ctx, endpoint, ec)); }
    socket_type accept(endpoint_type& endpoint, error_code& ec) { return accept(_Context(), endpoint, ec); }
    socket_type accept(endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(endpoint, ec)); }

    template <class CompletionToken>
    auto async_accept(io_context& ctx, endpoint_type& endpoint, CompletionToken&& token);
    template <class CompletionToken>
    auto async_accept(endpoint_type& endpoint, CompletionToken&& token)
    {
        return async_accept(_Context(), endpoint, forward<CompletionToken>(token));
    }
};

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_streambuf : public basic_streambuf<char>
{
public:
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;
    using clock_type = Clock;
    using time_point = typename clock_type::time_point;
    using duration = typename clock_type::duration;
    using wait_traits_type = WaitTraits;

    basic_socket_streambuf();
    explicit basic_socket_streambuf(basic_stream_socket<protocol_type> s);
    basic_socket_streambuf(const basic_socket_streambuf&) = delete;
    basic_socket_streambuf(basic_socket_streambuf&& rhs);

    virtual ~basic_socket_streambuf();

    basic_socket_streambuf& operator=(const basic_socket_streambuf&) = delete;
    basic_socket_streambuf& operator=(basic_socket_streambuf&& rhs);

    basic_socket_streambuf* connect(const endpoint_type& e);
    template <class... Args>
    basic_socket_streambuf* connect(Args&&...);

    basic_socket_streambuf* close();

    basic_socket<protocol_type>& socket();
    error_code error() const;

    time_point expiry() const;
    void expires_at(const time_point& t);
    void expires_after(const duration& d);

protected:
    virtual int_type underflow() override;
    virtual int_type pbackfail(int_type c = traits_type::eof()) override;
    virtual int_type overflow(int_type c = traits_type::eof()) override;
    virtual int sync() override;
    virtual streambuf* setbuf(char_type* s, streamsize n) override;

private:
    basic_stream_socket<protocol_type> socket_;
    error_code ec_;
    time_point expiry_;
};

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_iostream : public basic_iostream<char>
{
public:
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;
    using clock_type = Clock;
    using time_point = typename clock_type::time_point;
    using duration = typename clock_type::duration;
    using wait_traits_type = WaitTraits;

    basic_socket_iostream();
    explicit basic_socket_iostream(basic_stream_socket<protocol_type> s);
    basic_socket_iostream(const basic_socket_iostream&) = delete;
    basic_socket_iostream(basic_socket_iostream&& rhs);
    template <class... Args>
    explicit basic_socket_iostream(Args&&... args);

    basic_socket_iostream& operator=(const basic_socket_iostream&) = delete;
    basic_socket_iostream& operator=(basic_socket_iostream&& rhs);

    template <class... Args>
    void connect(Args&&... args);

    void close();

    basic_socket_streambuf<protocol_type, clock_type, wait_traits_type>* rdbuf() const;

    basic_socket<protocol_type>& socket();
    error_code error() const;

    time_point expiry() const;
    void expires_at(const time_point& t);
    void expires_after(const duration& d);

private:
    basic_socket_streambuf<protocol_type, clock_type, wait_traits_type> sb_;
};

struct _Always_true_condition
{
    template <class T1, class T2>
    bool operator()(T1, T2)
    {
        return true;
    }
};

template <class Protocol, class EndpointSequence, class ConnectCondition>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, error_code& ec)
{
    ec = error_code{};
    bool found{ false };
    for (auto& ep : endpoints)
    {
        if (c(ec, ep))
        {
            found = true;
            s.close(ec);
            if (!ec)
                s.open(ep.protocol(), ec);
            if (!ec)
                s.connect(ep, ec);
            if (!ec)
                return ep;
        }
    }
    if (!found)
        ec = make_error_code(socket_errc::not_found);
    return {};
}
template <class Protocol, class EndpointSequence, class ConnectCondition>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, endpoints, c, ec));
}
template <class Protocol, class EndpointSequence>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, error_code& ec)
{
    return connect(s, endpoints, _Always_true_condition{}, ec);
}
template <class Protocol, class EndpointSequence>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, endpoints, ec));
}

template <class Protocol, class InputIterator, class ConnectCondition>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, error_code& ec)
{
    ec = error_code{};
    bool found{ false };
    for (auto i{ first }; i != last; ++i)
    {
        typename Protocol::endpoint& ep{ *i };
        if (c(ec, ep))
        {
            found = true;
            s.close(ec);
            if (!ec)
                s.open(ep.protocol(), ec);
            if (!ec)
                s.connect(ep, ec);
            if (!ec)
                return ep;
        }
    }
    if (!found)
        ec = make_error_code(socket_errc::not_found);
    return {};
}
template <class Protocol, class InputIterator, class ConnectCondition>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, first, last, c, ec));
}
template <class Protocol, class InputIterator>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, error_code& ec)
{
    return connect(s, first, last, _Always_true_condition{}, ec);
}
template <class Protocol, class InputIterator>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, first, last, ec));
}

template <class Protocol, class EndpointSequence, class ConnectCondition, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, CompletionToken&& token);
template <class Protocol, class EndpointSequence, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, CompletionToken&& token)
{
    return async_connect(s, endpoints, _Always_true_condition{}, forward<CompletionToken>(token));
}

template <class Protocol, class InputIterator, class ConnectCondition, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, CompletionToken&& token);
template <class Protocol, class InputIterator, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, CompletionToken&& token)
{
    return async_connect(s, first, last, _Always_true_condition{}, forward<CompletionToken>(token));
}

} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::socket_errc> : public true_type
{
};
} // namespace std

#endif
