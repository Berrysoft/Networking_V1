#ifndef NET_SOCKET
#define NET_SOCKET

#include <experimental/timer>

#include <WinSock2.h>
#include <istream>
#include <streambuf>
#include <system_error>
#include <tuple>
#include <type_traits>

namespace std
{
namespace experimental::net
{
inline namespace v1
{
enum class socket_errc
{
    already_open = 1,
    not_found = 3
};

struct _Socket_category : error_category
{
    const char* name() const noexcept override { return "socket"; }
    string message(int value) const override
    {
        switch (value)
        {
        case static_cast<int>(socket_errc::already_open):
            return "Already open";
        case static_cast<int>(socket_errc::not_found):
            return "Element not found";
        default:
            return "socket error";
        }
    }
};

inline const error_category& socket_category() noexcept
{
    static _Socket_category instance{};
    return instance;
}

inline error_code make_error_code(socket_errc e) noexcept { return error_code{ static_cast<int>(e), socket_category() }; }
inline error_condition make_error_condition(socket_errc e) noexcept { return error_condition{ static_cast<int>(e), socket_category() }; }

template <typename Base>
class _Option_base
{
public:
    _Option_base() noexcept = default;
    _Option_base(Base val) : value_(val) {}

    template <class Protocol>
    void* data(const Protocol&) noexcept
    {
        return &value_;
    }
    template <class Protocol>
    const void* data(const Protocol&) const noexcept
    {
        return &value_;
    }
    template <class Protocol>
    size_t size(const Protocol&) const noexcept
    {
        return sizeof(value_);
    }
    template <class Protocol>
    void resize(const Protocol&, size_t s)
    {
        if (s != sizeof(value_))
            throw length_error{ "size exceeded" };
    }

protected:
    Base value_;
};

class socket_base
{
public:
    class broadcast : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_BROADCAST;
        }
    };
    class debug : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_DEBUG;
        }
    };
    class do_not_route : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_DONTROUTE;
        }
    };
    class keep_alive : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_KEEPALIVE;
        }
    };
    class out_of_band_inline : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_OOBINLINE;
        }
    };
    class receive_buffer_size : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_RCVBUF;
        }
    };
    class receive_low_watermark : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_RCVLOWAT;
        }
    };
    class reuse_address : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_REUSEADDR;
        }
    };
    class send_buffer_size : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_SNDBUF;
        }
    };
    class send_low_watermark : public _Option_base<int>
    {
    public:
        using _Option_base<int>::_Option_base;

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_SNDLOWAT;
        }
    };

    class linger : public _Option_base<::linger>
    {
    public:
        using _Option_base<::linger>::_Option_base;

        linger(bool e, chrono::seconds t) noexcept
        {
            enabled(e);
            timeout(t);
        };

        bool enabled() const noexcept { return value_.l_onoff; }
        void enabled(bool e) noexcept { value_.l_onoff = u_short(e); }

        chrono::seconds timeout() const noexcept { return chrono::seconds{ value_.l_linger }; }
        void timeout(chrono::seconds t) noexcept { value_.l_linger = (u_short)t.count(); }

        template <class Protocol>
        int level(const Protocol&) const noexcept
        {
            return SOL_SOCKET;
        }
        template <class Protocol>
        int name(const Protocol&) const noexcept
        {
            return SO_LINGER;
        }
    };

    enum class shutdown_type
    {
        shutdown_receive = SD_RECEIVE,
        shutdown_send = SD_SEND,
        shutdown_both = SD_BOTH
    };
    static constexpr shutdown_type shutdown_receive{ shutdown_type::shutdown_receive };
    static constexpr shutdown_type shutdown_send{ shutdown_type::shutdown_send };
    static constexpr shutdown_type shutdown_both{ shutdown_type::shutdown_both };

    enum class wait_type
    {
        wait_read = POLLIN,
        wait_write = POLLOUT,
        wait_error = POLLERR
    };
    static constexpr wait_type wait_read{ wait_type::wait_read };
    static constexpr wait_type wait_write{ wait_type::wait_write };
    static constexpr wait_type wait_error{ wait_type::wait_error };

    enum class message_flags
    {
        message_peek = MSG_PEEK,
        message_out_of_band = MSG_OOB,
        message_do_not_route = MSG_DONTROUTE
    };
    static constexpr message_flags message_peek{ message_flags::message_peek };
    static constexpr message_flags message_out_of_band{ message_flags::message_out_of_band };
    static constexpr message_flags message_do_not_route{ message_flags::message_do_not_route };

    static const int max_listen_connections{ 128 };

protected:
    socket_base() = default;
    ~socket_base() = default;
};

template <class Protocol>
class _Basic_socket : public socket_base
{
public:
    using executor_type = io_context::executor_type;
    using native_handle_type = SOCKET;
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    executor_type get_executor() noexcept { return ctx_->get_executor(); }
    io_context& _Context() { return *ctx_; }
    native_handle_type native_handle() { return socket_; }
    protocol_type _Protocol() { return protocol_; }

    void open(const protocol_type& protocol, error_code& ec)
    {
        if (is_open())
            ec = make_error_code(socket_errc::already_open);
        else
        {
            protocol_ = protocol;
            socket_ = ::WSASocketA(protocol.family(), protocol.type(), protocol.protocol(), nullptr, 0, WSA_FLAG_OVERLAPPED);
            if (is_open())
            {
                ec = error_code{};
                ::CreateIoCompletionPort(socket_, ctx_->_Native_handle(), 0, 0);
            }
            else
            {
                ec = error_code{ ::WSAGetLastError(), generic_category() };
            }
        }
    }
    void open(const protocol_type& protocol = {}) { _CHECK_ERROR_CODE_INVOKE(open(protocol, ec)); }

    void assign(const protocol_type& protocol, const native_handle_type& native_socket, error_code& ec)
    {
        if (is_open())
            ec = make_error_code(socket_errc::already_open);
        else
        {
            protocol_ = protocol;
            socket_ = native_socket;
            if (is_open())
            {
                ec = error_code{};
                ::CreateIoCompletionPort(socket_, ctx_->_Native_handle(), 0, 0);
            }
            else
            {
                ec = error_code{ ::WSAGetLastError(), generic_category() };
            }
        }
    }
    void assign(const protocol_type& protocol, const native_handle_type& native_socket) { _CHECK_ERROR_CODE_INVOKE(assign(protocol, native_socket, ec)); }

    native_handle_type release(error_code&)
    {
        native_handle_type h{ socket_ };
        socket_ = INVALID_SOCKET;
        return h;
    }
    native_handle_type release() { _CHECK_ERROR_CODE_INVOKE_FUNC(release(ec)); }

    bool is_open() const noexcept { return socket_ != INVALID_SOCKET; }

    void close(error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else
        {
            int r{ ::closesocket(socket_) };
            if (r != 0)
                ec = error_code{ ::WSAGetLastError(), generic_category() };
        }
    }
    void close() { _CHECK_ERROR_CODE_INVOKE(close(ec)); }

    void cancel(error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
    }
    void cancel() { _CHECK_ERROR_CODE_INVOKE(cancel(ec)); }

    template <class SettableSocketOption>
    void set_option(const SettableSocketOption& option, error_code& ec)
    {
        int r{ ::setsockopt(socket_, option.level(protocol_), option.name(protocol_), option.data(protocol_), option.size(protocol_)) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    template <class SettableSocketOption>
    void set_option(const SettableSocketOption& option)
    {
        _CHECK_ERROR_CODE_INVOKE(set_option(option, ec));
    }

    template <class GettableSocketOption>
    void get_option(GettableSocketOption& option, error_code& ec) const
    {
        int option_len{ option.size(protocol_) };
        int r{ ::getsockopt(socket_, option.level(protocol_), option.name(protocol_), option.data(protocol_), &option_len) };
        if (r == 0)
            option.resize(option_len);
        else
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    template <class GettableSocketOption>
    void get_option(GettableSocketOption& option) const
    {
        _CHECK_ERROR_CODE_INVOKE(get_option(option, ec));
    }

    template <class IoControlCommand>
    void io_control(IoControlCommand& command, error_code& ec)
    {
        int r{ ::ioctlsocket(native_handle(), command.name(), command.data()) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    template <class IoControlCommand>
    void io_control(IoControlCommand& command)
    {
        _CHECK_ERROR_CODE_INVOKE(io_control(command, ec));
    }

    void non_blocking(bool mode, error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else
        {
            mode_ = mode ? _Blocking_mode::non_blocking : _Blocking_mode::blocking;
        }
    }
    void non_blocking(bool mode) { _CHECK_ERROR_CODE_INVOKE(non_blocking(mode, ec)); }
    bool non_blocking() const { return mode_ != _Blocking_mode::non_blocking; }

    void native_non_blocking(bool mode, error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else if (!mode && non_blocking())
            ec = make_error_code(errc::invalid_argument);
        else
        {
            unsigned long m = mode ? 0 : 1;
            int r{ ::ioctlsocket(socket_, FIONBIO, &m) };
            mode_ = mode ? _Blocking_mode::native_non_blocking : _Blocking_mode::non_blocking;
            if (r != 0)
                ec = error_code{ ::WSAGetLastError(), generic_category() };
        }
    }
    void native_non_blocking(bool mode) { _CHECK_ERROR_CODE_INVOKE(native_non_blocking(mode, ec)); }
    bool native_non_blocking() const { return mode_ == _Blocking_mode::native_non_blocking; }

    void bind(const endpoint_type& endpoint, error_code& ec)
    {
        int r{ ::bind(socket_, endpoint.data(), endpoint.size()) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void bind(const endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE(bind(endpoint, ec)); }

    endpoint_type local_endpoint(error_code& ec) const
    {
        endpoint_type endpoint{};
        int endpoint_len{ endpoint.capacity() };
        int r{ ::getsockname(socket_, endpoint.data(), &endpoint_len) };
        if (r == 0)
            endpoint.resize(endpoint_len);
        else
        {
            ec = error_code{ ::WSAGetLastError(), generic_category() };
            return {};
        }
        return endpoint;
    }
    endpoint_type local_endpoint() const { _CHECK_ERROR_CODE_INVOKE_FUNC(local_endpoint(ec)); }

    void wait(wait_type w, error_code& ec)
    {
        if (!is_open())
            ec = make_error_code(errc::bad_file_descriptor);
        else
        {
            pollfd fd{};
            fd.fd = socket_;
            fd.events = static_cast<SHORT>(w);
            fd.revents = 0;
            int r{ ::WSAPoll(&fd, 1, -1) };
            if (r == SOCKET_ERROR)
                ec = error_code{ ::WSAGetLastError(), generic_category() };
        }
    }
    void wait(wait_type w) { _CHECK_ERROR_CODE_INVOKE(wait(w, ec)); }

    template <class CompletionToken>
    auto async_wait(wait_type w, CompletionToken&& token);

protected:
    explicit _Basic_socket(io_context& ctx) : ctx_(&ctx), socket_(INVALID_SOCKET), mode_(_Blocking_mode::blocking) {}
    _Basic_socket(io_context& ctx, const protocol_type& protocol) : ctx_(&ctx), protocol_(protocol), mode_(_Blocking_mode::blocking) { open(protocol); }
    _Basic_socket(io_context& ctx, const protocol_type& protocol, const native_handle_type& native_socket) : ctx_(&ctx), protocol_(protocol), socket_(native_socket), mode_(_Blocking_mode::blocking) {}
    _Basic_socket(const _Basic_socket&) = delete;
    _Basic_socket(_Basic_socket&& rhs) : ctx_(rhs.ctx_), protocol_(rhs.protocol_), socket_(rhs.socket_), mode_(rhs.mode_) { rhs.socket_ = INVALID_SOCKET; }
    template <class OtherProtocol>
    _Basic_socket(_Basic_socket<OtherProtocol>&& rhs) : ctx_(rhs.ctx_), protocol_(rhs.protocol_), socket_(rhs.socket_), mode_(rhs.mode)
    {
        rhs.socket_ = INVALID_SOCKET;
    }

    virtual ~_Basic_socket()
    {
        if (is_open())
        {
            int r{ ::closesocket(socket_) };
        }
    }

    _Basic_socket& operator=(const _Basic_socket&) = delete;
    _Basic_socket& operator=(_Basic_socket&& rhs)
    {
        ctx_ = rhs.ctx_;
        protocol_ = rhs.protocol_;
        socket_ = rhs.socket_;
        rhs.socket_ = INVALID_SOCKET;
        mode_ = rhs.mode_;
        return *this;
    }
    template <class OtherProtocol>
    _Basic_socket& operator=(_Basic_socket<OtherProtocol>&& rhs)
    {
        ctx_ = rhs.ctx_;
        protocol_ = rhs.protocol_;
        socket_ = rhs.socket_;
        rhs.socket_ = INVALID_SOCKET;
        mode_ = rhs.mode_;
        return *this;
    }

private:
    io_context* ctx_;
    protocol_type protocol_;
    SOCKET socket_;
    enum class _Blocking_mode
    {
        blocking,
        non_blocking,
        native_non_blocking
    } mode_;
};

template <class Protocol>
class basic_socket : public _Basic_socket<Protocol>
{
public:
    bool at_mark(error_code& ec) const
    {
        unsigned long value;
        int r{ ::ioctlsocket(native_handle(), SIOCATMARK, &value) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return value != 0;
    }
    bool at_mark() const { return _CHECK_ERROR_CODE_INVOKE_FUNC(at_mark(ec)); }

    size_t available(error_code& ec) const
    {
        unsigned long value;
        int r{ ::ioctlsocket(native_handle(), FIONREAD, &value) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return static_cast<size_t>(value);
    }
    size_t available() const { _CHECK_ERROR_CODE_INVOKE_FUNC(avaliable(ec)); }

    void shutdown(shutdown_type what, error_code& ec)
    {
        int r{ ::shutdown(native_handle(), static_cast<int>(what)) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void shutdown(shutdown_type what) { _CHECK_ERROR_CODE_INVOKE(shutdown(what, ec)); }

    endpoint_type remote_endpoint() const
    {
        endpoint_type endpoint{};
        int endpoint_len{ endpoint.capacity() };
        int r{ ::getpeername(native_handle(), endpoint.data(), &endpoint_len) };
        if (r == 0)
            endpoint.resize(endpoint_len);
        else
        {
            ec = error_code{ ::WSAGetLastError(), generic_category() };
            return {};
        }
        return endpoint;
    }

    endpoint_type remote_endpoint(error_code& ec) const;

    void connect(const endpoint_type& endpoint, error_code& ec)
    {
        if (!is_open())
        {
            open(endpoint.protocol(), ec);
            if (ec)
                return;
        }
        int r{ ::connect(native_handle(), endpoint.data(), endpoint.size()) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void connect(const endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE(connect(endpoint, ec)); }

    template <class CompletionToken>
    auto async_connect(const endpoint_type& endpoint, CompletionToken&& token);

protected:
    using _Basic_socket<Protocol>::_Basic_socket;
    basic_socket(io_context& ctx, const endpoint_type& endpoint) : _Basic_socket<Protocol>(ctx)
    {
        open(endpoint.protocol());
        bind(endpoint);
    }
};

template <class Buffer, class BufferSequence>
tuple<vector<::WSABUF>, size_t> _Native_buffers(const BufferSequence& buffers)
{
    vector<::WSABUF> buf{};
    auto i{ buffer_sequence_begin(buffers) };
    auto end{ buffer_sequence_end(buffers) };
    size_t s{ 0 };
    for (; i != end; ++i)
    {
        Buffer b{ *i };
        buf.emplace_back({ b.size(), b.data() });
        s += b.size();
    }
    return make_tuple(move(buf), s);
}

template <class Protocol>
class _Basic_datagram_socket : public basic_socket<Protocol>
{
public:
    using native_handle_type = SOCKET;
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    explicit _Basic_datagram_socket(io_context& ctx) : basic_socket<Protocol>(ctx) {}
    _Basic_datagram_socket(io_context& ctx, const protocol_type& protocol) : basic_socket<Protocol>(ctx, protocol) {}
    _Basic_datagram_socket(io_context& ctx, const endpoint_type& endpoint) : basic_socket<Protocol>(ctx, endpoint) {}
    _Basic_datagram_socket(io_context& ctx, const protocol_type& protocol, const native_handle_type& native_socket) : basic_socket<Protocol>(ctx, protocol, native_socket) {}
    _Basic_datagram_socket(const _Basic_datagram_socket&) = delete;
    _Basic_datagram_socket(_Basic_datagram_socket&& rhs) : basic_socket<Protocol>(move(rhs)) {}
    template <class OtherProtocol>
    _Basic_datagram_socket(_Basic_datagram_socket<OtherProtocol>&& rhs) : basic_socket<Protocol>(move(rhs))
    {
    }

    ~_Basic_datagram_socket() override {}

    _Basic_datagram_socket& operator=(const _Basic_datagram_socket&) = delete;
    _Basic_datagram_socket& operator=(_Basic_datagram_socket&& rhs)
    {
        basic_socket<Protocol>::operator=(move(rhs));
        return *this;
    }
    template <class OtherProtocol>
    _Basic_datagram_socket& operator=(_Basic_datagram_socket<OtherProtocol>&& rhs)
    {
        basic_socket<Protocol>::operator=(move(rhs));
        return *this;
    }

    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, message_flags flags, error_code& ec)
    {
        vector<::WSABUF> buf{ _Native_buffers<mutable_buffer>(buffers) };
        DWORD rec{ 0 };
        int r{ ::WSARecv(native_handle(), buf.data(), buf.size(), &rec, &flags, nullptr, nullptr) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return rec;
    }
    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, message_flags flags)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(receive(buffers, flags, ec));
    }
    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers, error_code& ec)
    {
        return receive(buffers, message_flags{}, ec);
    }
    template <class MutableBufferSequence>
    size_t receive(const MutableBufferSequence& buffers)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(receive(buffers, ec));
    }

    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive(const MutableBufferSequence& buffers, message_flags flags, CompletionToken&& token)
    {
        async_completion<CompletionToken, void(error_code, size_t)> init{ token };
        if (flags & socket_base::message_peek)
        {
            token(make_error_code(errc::invalid_argument), 0);
        }
        else
        {
            auto [data, n] = _Native_buffers<mutable_buffer>(buffers);
            _Io_operation* op = new _Io_operation{};
            op->overlapped.hEvent = ::WSACreateEvent();
            op->operation = [token = forward<CompletionToken>(token)](_Io_operation*, DWORD n) { token(error_code{}, n); };
            DWORD rec{ 0 };
            int r{ ::WSARecv(native_handle(), data.data(), n, &rec, &flags, op, nullptr) };
            if (r != 0)
            {
                int err = ::WSAGetLastError();
                if (err != WSA_IO_PENDING)
                {
                    token(error_code{ err, generic_category() }, 0);
                }
            }
        }
        return init.result.get();
    }
    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive(const MutableBufferSequence& buffers, CompletionToken&& token)
    {
        return async_receive(buffers, message_flags{}, forward<CompletionToken>(token));
    }

    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, message_flags flags, error_code& ec)
    {
        vector<::WSABUF> buf{ _Native_buffers<const_buffer>(buffers) };
        DWORD s{ 0 };
        int r{ ::WSASend(native_handle(), buf.data(), buf.size(), &s, flags, nullptr, nullptr) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return s;
    }
    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, message_flags flags)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(send(buffers, flags, ec));
    }
    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers, error_code& ec)
    {
        return send(buffers, message_flags{}, ec);
    }
    template <class ConstBufferSequence>
    size_t send(const ConstBufferSequence& buffers)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(send(buffers, ec));
    }

    template <class ConstBufferSequence, class CompletionToken>
    auto async_send(const ConstBufferSequence& buffers, message_flags flags, CompletionToken&& token)
    {
        async_completion<CompletionToken, void(error_code, size_t)> init{ token };
        if (flags & socket_base::message_peek)
        {
            token(make_error_code(errc::invalid_argument), 0);
        }
        else
        {
            auto [data, n] = _Native_buffers<const_buffer>(buffers);
            _Io_operation* op = new _Io_operation{};
            op->overlapped.hEvent = ::WSACreateEvent();
            op->operation = [token = forward<CompletionToken>(token)](_Io_operation*, DWORD n) { token(error_code{}, n); };
            DWORD s{ 0 };
            int r{ ::WSASend(native_handle(), data.data(), n, &s, flags, op, nullptr) };
            if (r != 0)
            {
                int err = ::WSAGetLastError();
                if (err != WSA_IO_PENDING)
                {
                    token(error_code{ err, generic_category() }, 0);
                }
            }
        }
        return init.result.get();
    }
    template <class ConstBufferSequence, class CompletionToken>
    auto async_send(const ConstBufferSequence& buffers, CompletionToken&& token)
    {
        return async_send(buffers, message_flags{}, forward<CompletionToken>(token));
    }
};

template <class Protocol>
class basic_datagram_socket : public _Basic_datagram_socket<Protocol>
{
public:
    using _Basic_datagram_socket<Protocol>::_Basic_datagram_socket;

    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, message_flags flags, error_code& ec)
    {
        vector<::WSABUF> buf{ _Native_buffers<mutable_buffer>(buffers) };
        DWORD rec{ 0 };
        int r{ ::WSARecvFrom(native_handle(), buf.data(), buf.size(), &rec, flags, sender.data(), sender.size(), nullptr, nullptr) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return rec;
    }
    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, message_flags flags)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(receive_from(buffers, sender, flags, ec));
    }
    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, error_code& ec)
    {
        return receive_from(buffers, sender, message_flags{}, ec);
    }
    template <class MutableBufferSequence>
    size_t receive_from(const MutableBufferSequence& buffers, endpoint_type& sender)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(receive_from(buffers, sender, ec));
    }

    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, message_flags flags, CompletionToken&& token);
    template <class MutableBufferSequence, class CompletionToken>
    auto async_receive_from(const MutableBufferSequence& buffers, endpoint_type& sender, CompletionToken&& token)
    {
        return async_receive_from(buffers, sender, message_flags{}, forward<CompletionToken>(token));
    }

    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, message_flags flags, error_code& ec)
    {
        vector<::WSABUF> buf{ _Native_buffers<const_buffer>(buffers) };
        DWORD s{ 0 };
        int r{ ::WSASendTo(native_handle(), buf.data(), buf.size(), &s, flags, sender.data(), sender.size(), nullptr, nullptr) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        return s;
    }
    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, message_flags flags)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(send_to(buffers, recipient, flags, ec));
    }
    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, error_code& ec)
    {
        return send_to(buffers, recipient, message_flags{}, ec);
    }
    template <class ConstBufferSequence>
    size_t send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient)
    {
        _CHECK_ERROR_CODE_INVOKE_FUNC(send_to(buffers, recipient, ec));
    }

    template <class ConstBufferSequence, class CompletionToken>
    auto async_send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, message_flags flags, CompletionToken&& token);
    template <class ConstBufferSequence, class CompletionToken>
    auto async_send_to(const ConstBufferSequence& buffers, const endpoint_type& recipient, CompletionToken&& token)
    {
        return async_send_to(buffers, recipient, message_flags{}, forward<CompletionToken>(token));
    }
};

template <class Protocol>
class basic_stream_socket : public _Basic_datagram_socket<Protocol>
{
public:
    using _Basic_datagram_socket<Protocol>::_Basic_datagram_socket;

    template <class MutableBufferSequence>
    size_t read_some(const MutableBufferSequence& buffers, error_code& ec)
    {
        return receive(buffers, ec);
    }
    template <class MutableBufferSequence>
    size_t read_some(const MutableBufferSequence& buffers)
    {
        return _CHECK_ERROR_CODE_INVOKE_FUNC(read_some(buffers, ec));
    }

    template <class MutableBufferSequence, class CompletionToken>
    auto async_read_some(const MutableBufferSequence& buffers, CompletionToken&& token)
    {
        return async_receive(buffers, forward<CompletionToken>(token));
    }

    template <class ConstBufferSequence>
    size_t write_some(const ConstBufferSequence& buffers, error_code& ec)
    {
        return send(buffers, ec);
    }
    template <class ConstBufferSequence>
    size_t write_some(const ConstBufferSequence& buffers)
    {
        return _CHECK_ERROR_CODE_INVOKE_FUNC(write_some(buffers, ec));
    }

    template <class ConstBufferSequence, class CompletionToken>
    auto async_write_some(const ConstBufferSequence& buffers, CompletionToken&& token)
    {
        return async_send(buffers, forward<CompletionToken>(token));
    }
};

template <class AcceptableProtocol>
class basic_socket_acceptor : public _Basic_socket<AcceptableProtocol>
{
public:
    using socket_type = typename protocol_type::socket;

    using _Basic_socket<AcceptableProtocol>::_Basic_socket;
    basic_socket_acceptor(io_context& ctx, const endpoint_type& endpoint, bool reuse_addr = true) : _Basic_socket<AcceptableProtocol>(ctx)
    {
        open(endpoint.protocol());
        if (reuse_addr)
            set_option(reuse_address{ int(true) });
        bind(endpoint);
        listen();
    }

    void listen(int backlog, error_code& ec)
    {
        int r{ ::listen(native_handle(), backlog) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
    }
    void listen(int backlog = max_listen_connections) { _CHECK_ERROR_CODE_INVOKE(listen(backlog, ec)); }

    void enable_connection_aborted(bool mode);
    bool enable_connection_aborted() const;

    socket_type accept(io_context& ctx, error_code& ec)
    {
        native_handle_type h{ ::accept(native_handle(), nullptr, 0) };
        if (h != INVALID_SOCKET)
            return socket_type{ ctx, _Protocol(), h };
        else
            return socket_type{ ctx };
    }
    socket_type accept(io_context& ctx) { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(ctx, ec)); }
    socket_type accept(error_code& ec) { accept(_Context(), ec); }
    socket_type accept() { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(ec)); }

    template <class CompletionToken>
    auto async_accept(io_context& ctx, CompletionToken&& token);
    template <class CompletionToken>
    auto async_accept(CompletionToken&& token)
    {
        return accept(_Context(), forward<CompletionToken>(token));
    }

    socket_type accept(io_context& ctx, endpoint_type& endpoint, error_code& ec)
    {
        int endpoint_len{ endpoint.capacity() };
        native_handle_type h{ ::accept(native_handle(), endpoint.data(), &endpoint_len) };
        if (h != INVALID_SOCKET)
        {
            endpoint.resize(endpoint_len);
            return socket_type{ ctx, _Protocol(), h };
        }
        else
        {
            return socket_type{ ctx };
        }
    }
    socket_type accept(io_context& ctx, endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(ctx, endpoint, ec)); }
    socket_type accept(endpoint_type& endpoint, error_code& ec) { return accept(_Context(), endpoint, ec); }
    socket_type accept(endpoint_type& endpoint) { _CHECK_ERROR_CODE_INVOKE_FUNC(accept(endpoint, ec)); }

    template <class CompletionToken>
    auto async_accept(io_context& ctx, endpoint_type& endpoint, CompletionToken&& token);
    template <class CompletionToken>
    auto async_accept(endpoint_type& endpoint, CompletionToken&& token)
    {
        return async_accept(_Context(), endpoint, forward<CompletionToken>(token));
    }
};

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_streambuf : public basic_streambuf<char>
{
public:
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;
    using clock_type = Clock;
    using time_point = typename clock_type::time_point;
    using duration = typename clock_type::duration;
    using wait_traits_type = WaitTraits;

    basic_socket_streambuf() : socket_(_Context()) { _Init_buffers(); }
    explicit basic_socket_streambuf(basic_stream_socket<protocol_type> s) : socket_(move(s)) { _Init_buffers(); }
    basic_socket_streambuf(const basic_socket_streambuf&) = delete;
    basic_socket_streambuf(basic_socket_streambuf&& rhs) : socket_(move(rhs.socket_)), ec_(rhs.ec_), expiry_(rhs.expiry_)
    {
        get_buffer_.swap(rhs.get_buffer_);
        put_buffer_.swap(rhs.put_buffer_);
        rhs.ec_.clear();
        rhs.expiry_ = time_point::max();
        rhs._Init_buffers();
    }

    virtual ~basic_socket_streambuf() { overflow(); }

    basic_socket_streambuf& operator=(const basic_socket_streambuf&) = delete;
    basic_socket_streambuf& operator=(basic_socket_streambuf&& rhs)
    {
        close();
        get_buffer_.swap(rhs.get_buffer_);
        put_buffer_.swap(rhs.put_buffer_);
        socket_ = move(rhs.socket_);
        ec_ = rhs.ec_;
        rhs.ec_.clear();
        expiry_ = rhs.expiry_;
        rhs.expiry_ = time_point::max();
        rhs._Init_buffers();
        return *this;
    }

    basic_socket_streambuf* connect(const endpoint_type& e)
    {
        socket_.close(ec_);
        if (!ec_) return nullptr;
        socket_.open(e.protocol(), ec_);
        if (!ec_) return nullptr;
        int r{ ::connect(socket_.native_handle(), e.data(), e.size()) };
        if (r != 0)
            ec = error_code{ ::WSAGetLastError(), generic_category() };
        if (!ec_) return nullptr;
        return this;
    }
    template <class... Args>
    basic_socket_streambuf* connect(Args&&...)
    {
        endpoint_type e{ protocol_type::resolver(_Context()).resolve(forward<Args>(args)...) };
        return connect(e);
    }

    basic_socket_streambuf* close()
    {
        overflow(traits_type::eof());
        socket_.close(ec_);
        if (!ec_) return nullptr;
        return this;
    }

    basic_socket<protocol_type>& socket() { return socket_; }
    error_code error() const { return ec_; }

    time_point expiry() const { return expiry_; }
    void expires_at(const time_point& t) { ecpiry_ = t; }
    void expires_after(const duration& d) { expires_at(clock_type::now() + d); }

protected:
    virtual int_type underflow() override
    {
        if (gptr() != egptr())
            return traits_type::eof();
        while (true)
        {
            if (expiry_ < clock_type::now())
            {
                ec_ = make_error_code(errc::timed_out);
                return traits_type::eof();
            }
            if (!socket_.native_non_blocking())
                socket_.native_non_blocking(true, ec_);
            DWORD bytes;
            WSABUF buf{ get_buffer_.data(), get_buffer_.size() };
            int r{ ::WSARecv(socket_.native_handle(), &buf, buf.len, &bytes, 0, nullptr, nullptr) };
            if (r != 0)
            {
                ec_ = error_code{ ::WSAGetLastError(), generic_category() };
                return traits_type::eof();
            }
            if (bytes > 0)
            {
                setg(get_buffer_.data(), get_buffer_.data() + _Putback_max, get_buffer_.data() + _Putback_max + bytes);
                return traits_type::to_int_type(*gptr());
            }
            if (bytes == 0)
            {
                ec_ = make_error_code(stream_errc::eof);
                return traits_type::eof();
            }
            if (!ec)
                return traits_type::eof();
            pollfd fds;
            fds.fd = s;
            fds.events = POLLIN;
            fds.revents = 0;
            r = ::WSAPoll(&fds, 1, chrono::duration_cast<chrono::milliseconds>(expiry_ - time_point::now()).count());
            if (r != 0)
                return traits_type::eof();
        }
    }
    virtual int_type pbackfail(int_type c = traits_type::eof()) override;
    virtual int_type overflow(int_type c = traits_type::eof()) override
    {
        char_type ch = traits_type::to_char_type(c);
        const_buffer output_buffer;
        if (put_buffer_.empty())
        {
            if (traits_type::eq_int_type(c, traits_type::eof()))
                return traits_type::not_eof(c); // Nothing to do.
            output_buffer = buffer(&ch, sizeof(char_type));
        }
        else
        {
            output_buffer = buffer(pbase(), (pptr() - pbase()) * sizeof(char_type));
        }
        while (output_buffer.size() > 0)
        {
            // Check if we are past the expiry time.
            if (expiry_ < time_point::now())
            {
                ec_ = make_error_code(errc::timed_out);
                return traits_type::eof();
            }

            // Try to complete the operation without blocking.
            if (!socket_.native_non_blocking())
                socket_.native_non_blocking(true, ec_);
            DWORD bytes;
            WSABUF buf{ get_buffer_.data(), get_buffer_.size() };
            int r{ ::WSASend(socket_.native_handle(), &buf, buf.len, &bytes, 0, nullptr, nullptr) };
            if (r != 0)
            {
                ec_ = error_code{ ::WSAGetLastError(), generic_category() };
                return traits_type::eof();
            }
            if (bytes > 0)
            {
                output_buffer += static_cast<size_t>(bytes);
                continue;
            }
            if (!ec)
                return traits_type::eof();
            pollfd fds;
            fds.fd = s;
            fds.events = POLLOUT;
            fds.revents = 0;
            r = ::WSAPoll(&fds, 1, chrono::duration_cast<chrono::milliseconds>(expiry_ - time_point::now()).count());
            if (r != 0)
                return traits_type::eof();
        }
        if (!put_buffer_.empty())
        {
            setp(put_buffer_.data(), put_buffer_.data() + put_buffer_.size());
            if (traits_type::eq_int_type(c, traits_type::eof()))
                return traits_type::not_eof(c);
            *pptr() = ch;
            pbump(1);
        }
        return c;
    }
    virtual int sync() override { return overflow(); }
    virtual streambuf* setbuf(char_type* s, streamsize n) override
    {
        if (pptr() == pbase() && s == nullptr && n == 0)
        {
            put_buffer_.clear();
            setp(nullptr, nullptr);
            sync();
            return this;
        }
        return nullptr;
    }

private:
    static io_context& _Context()
    {
        static io_context ctx;
        return ctx;
    }

    inline constexpr size_t _Putback_max{ 8 };
    void _Init_buffers()
    {
        setg(get_buffer_.data(), get_buffer_.data() + _Putback_max, get_buffer_.data() + _Putback_max);
        if (put_buffer_.empty())
            setp(nullptr, nullptr);
        else
            setp(put_buffer_.data(), put_buffer_.data() + put_buffer_.size());
    }

    vector<char> get_buffer_{ 512 };
    vector<char> put_buffer_{ 512 };
    basic_stream_socket<protocol_type> socket_;
    error_code ec_;
    time_point expiry_{ time_point::max() };
};

template <class Protocol, class Clock = chrono::steady_clock, class WaitTraits = wait_traits<Clock>>
class basic_socket_iostream : public basic_iostream<char>
{
public:
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;
    using clock_type = Clock;
    using time_point = typename clock_type::time_point;
    using duration = typename clock_type::duration;
    using wait_traits_type = WaitTraits;

    basic_socket_iostream() : basic_iostream<char>(&sb_), sb_() { setf(ios_base::unitbuf); }
    explicit basic_socket_iostream(basic_stream_socket<protocol_type> s) : basic_iostream<char>(&sb_), sb_(move(s)) { setf(ios_base::unitbuf); }
    basic_socket_iostream(const basic_socket_iostream&) = delete;
    basic_socket_iostream(basic_socket_iostream&& rhs) : basic_iostream<char>(&sb_), sb_(move(rhs.sb_)) { set_rdbuf(&sb_); }
    template <class... Args>
    explicit basic_socket_iostream(Args&&... args) : basic_iostream<char>(&sb_), sb_()
    {
        setf(ios_base::unitbuf);
        connect(forward<Args>(args)...);
    }

    basic_socket_iostream& operator=(const basic_socket_iostream&) = delete;
    basic_socket_iostream& operator=(basic_socket_iostream&& rhs)
    {
        basic_iostream<char>::operator=(rhs);
        sb_ = move(rhs.sb_);
        return *this;
    }

    template <class... Args>
    void connect(Args&&... args)
    {
        if (!rdbuf()->connect(forward<Args>(args)...))
        {
            setstate(failbit);
        }
    }

    void close() { rdbuf()->close(); }

    basic_socket_streambuf<protocol_type, clock_type, wait_traits_type>* rdbuf() const
    {
        return const_cast<basic_socket_streambuf<protocol_type, clock_type, wait_traits_type>*>(addressof(sb_));
    }

    basic_socket<protocol_type>& socket() { return rdbuf()->socket(); }
    error_code error() const { return rdbuf()->error(); }

    time_point expiry() const { return rdbuf()->expiry(); }
    void expires_at(const time_point& t) { rdbuf()->expires_at(t); }
    void expires_after(const duration& d) { rdbuf()->expires_after(d); }

private:
    basic_socket_streambuf<protocol_type, clock_type, wait_traits_type> sb_;
};

struct _Always_true_condition
{
    template <class T1, class T2>
    bool operator()(T1, T2)
    {
        return true;
    }
};

template <class Protocol, class EndpointSequence, class ConnectCondition>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, error_code& ec)
{
    ec = error_code{};
    bool found{ false };
    for (auto& ep : endpoints)
    {
        if (c(ec, ep))
        {
            found = true;
            s.close(ec);
            if (!ec)
                s.open(ep.protocol(), ec);
            if (!ec)
                s.connect(ep, ec);
            if (!ec)
                return ep;
        }
    }
    if (!found)
        ec = make_error_code(socket_errc::not_found);
    return {};
}
template <class Protocol, class EndpointSequence, class ConnectCondition>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, endpoints, c, ec));
}
template <class Protocol, class EndpointSequence>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, error_code& ec)
{
    return connect(s, endpoints, _Always_true_condition{}, ec);
}
template <class Protocol, class EndpointSequence>
inline typename Protocol::endpoint connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, endpoints, ec));
}

template <class Protocol, class InputIterator, class ConnectCondition>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, error_code& ec)
{
    ec = error_code{};
    bool found{ false };
    for (auto i{ first }; i != last; ++i)
    {
        typename Protocol::endpoint& ep{ *i };
        if (c(ec, ep))
        {
            found = true;
            s.close(ec);
            if (!ec)
                s.open(ep.protocol(), ec);
            if (!ec)
                s.connect(ep, ec);
            if (!ec)
                return ep;
        }
    }
    if (!found)
        ec = make_error_code(socket_errc::not_found);
    return {};
}
template <class Protocol, class InputIterator, class ConnectCondition>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, first, last, c, ec));
}
template <class Protocol, class InputIterator>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, error_code& ec)
{
    return connect(s, first, last, _Always_true_condition{}, ec);
}
template <class Protocol, class InputIterator>
inline InputIterator connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last)
{
    _CHECK_ERROR_CODE_INVOKE_FUNC(connect(s, first, last, ec));
}

template <class Protocol, class EndpointSequence, class ConnectCondition, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, ConnectCondition c, CompletionToken&& token);
template <class Protocol, class EndpointSequence, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, const EndpointSequence& endpoints, CompletionToken&& token)
{
    return async_connect(s, endpoints, _Always_true_condition{}, forward<CompletionToken>(token));
}

template <class Protocol, class InputIterator, class ConnectCondition, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, ConnectCondition c, CompletionToken&& token);
template <class Protocol, class InputIterator, class CompletionToken>
inline auto async_connect(basic_socket<Protocol>& s, InputIterator first, InputIterator last, CompletionToken&& token)
{
    return async_connect(s, first, last, _Always_true_condition{}, forward<CompletionToken>(token));
}

} // namespace v1
} // namespace experimental::net
template <>
struct is_error_code_enum<experimental::net::v1::socket_errc> : public true_type
{
};
} // namespace std

#endif
